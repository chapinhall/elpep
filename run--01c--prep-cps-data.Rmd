
<!-- This .Rmd file is set up to run either independently by checking for 
the presence of necessary objects in the global environment and running 
related scripts if not, or also as a child to the "main-doc". For that latter
reason, comments and headings that are not relevant to a final report to
pubic audiences are suppressed or moved to code chunks that can optionally be 
`echo`ed as desired. -->

```{r}
# set flags for running this cps script
print_documentation <- FALSE
```

```{r}
# run scripts for necessary packages and objects as necessary
if (!"chHexs"        %in% objects()) source("settings--main.R", echo = FALSE)
if (!"my_state_abbr" %in% objects()) source("settings--profile.R", echo = FALSE)
if (!"bin_age"       %in% objects()) source("method--general-helper-functions.R", echo = FALSE)
```

Current Population Survey (CPS) microdata are downloaded from the [Census Application Program Interface (API)](https://www.census.gov/data/developers/data-sets/census-microdata-api/cps/basic.html) and (https://www.census.gov/data/developers/data-sets/census-microdata-api.CPS_ASEC.html) from `r base_year` through the most recent available month.

The sample is restricted to families of head of householders. This is practically driven by the availability of family income as available only for those individuals who are related to the head of household.

Hawaii and Alaska are dropped, as they follow different federal poverty guidelines than other states, and are expected to have clearly distinct economic dynamics.

<!-- Note that subsetting to match households with both pre and post measures only occurs later, at the point that the method calculates transition ratios. We perform this match--and implicit subsetting--at that stage because a range of choices is may be reasonable and we save the application of discretion for that later stage. -->

```{r read and subset cps microdata}
cps <- fread(file = glue("{input_path}cpsbm.csv"))
cps_sub <- 
  cps %>% 
  .[#cpsid != 0 &                           # This rules out ASEC over-sample households (see documentation on `CPSID`)
    #(ASECFLAG == 2 | is.na(ASECFLAG))  &   # This excludes March ASEC sample 
                                           # Using both ASEC and monthly causes some issues -- e.g., generate WTFINL == NA for March ASEC; double counts individuals for March
                                           # See https://cps.ipums.org/cps/cps_linking_documentation.shtml
    (!gestfips %in% c(2, 15))          &   # This excludes HI and AK
    between(perrp, 1, 8)] # This subsets to only related members of the family

rm(cps)
gc()

#hk /!\ Notes
## Current code excludes sub-families (anyone with RELATE > 1001) and assumes NO multi-family household
## Multi-generational family -- parents/head/child/siblings/nephew/niece... 
## Come back to check how to address this

```

<!-- ### Build timing indicators -->

```{r develop CPS timing flags}
cps_timing <-
  cps_sub %>%
  .[j = `:=`(baseline_year  = as.numeric(substr(start_time, 1, 4)), 
             baseline_month = as.numeric(substr(start_time, 5, 6)))] %>%
  .[j = `:=`(months_since_base = (hryear4 - baseline_year)*12 + (hrmonth - baseline_month))]
cps_timing[j = table(months_since_base)] # Values should be 0-3, 12-15 (CPS samples are interviewed for 4 consecutive months, not interviewed for the next 8 months, and then interviewed again for the next 4 months). /!\ Using CPS from IPUMS, there were cases -- though very small -- that had values of 9-11, which may be due to an error constructing `CPSID` in IPUMS. This issue is fixed using CPS from the Census.

if (FALSE) {
  cps_timing <- cps_timing %>%
    mutate(months_since_base = if_else(hrmis <= 4, hrmis - 1, hrmis + 8 - 1))
}

cps_timing[j = `:=`(is_baseline = months_since_base == 0,
                    # /!\ This selects a single post-period survey. Notably, it's the first time in which
                    # the household has been seen. That will standardize samples with respect to calendar
                    # time, but not with respect to time since initial survey. Return to consider whether
                    # this is okay, if we want to standardized by e.g. months_since_base == 12 or 15, or
                    # if we want the baseline to be max(months_since_base) - 12.
                    is_post     = months_since_base == max(months_since_base) & months_since_base >= 12,
                    year_month  = paste(hryear4, str_pad(hrmonth, side = "left", width = 2, pad = "0"), sep = "-"),
                    # build an indicator for whether the data are around great 
                    # recession -- surrounding 2007-2009 -- vs COVID, surrounding
                    # 2019 and after
                    is_validation = hryear4 < 2015),
           by = cpsid]

cps_timing_sub <- 
  cps_timing[is_baseline == TRUE | is_post == TRUE] #subset to baseline or post data only #/!\ As a result, we end up having different #obs using the CPS from the Census.

rm(cps_sub)
gc()
```

```{r examine how many cases have--or lack--baseline income data, eval = developer_mode}
# Examine which, and how many, household do not have baseline data.
cps_timing_sub[j = .(has_baseline = max(is_baseline),
                     has_month0   = max(months_since_base == 0),
                     start_time   = start_time), #/!\ The code doesn't run (error at line 95) before adding this term -- perhaps sth to do with [j = .()]?
               by = cpsid] %>% 
  .[j = .(pct_has_baseline = mean(has_baseline),
          pct_has_month0   = mean(has_month0)),
    by = .(year_month = as.character(start_time))] %>% 
  .[order(year_month)] %>% 
  pivot_longer(cols = -year_month) %>%
  ggplot(aes(x = year_month,
             y = value,
             color = name,
             label = year_month)) +
  geom_point() +
  geom_text(hjust = 1.1,
            angle = 90,
            color = "black",
            alpha = 0.8,
            size = 2) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, 
                                   size = 6),
        legend.position = "bottom")

```

```{r tabulate months of available CPS data, eval = developer_mode}
# Examine available periods, by classification as baseline and post-period.

cps_timing_sub[j = .(n = comma(.N)),
               by = .(is_baseline, is_post, is_validation, hryear4)] %>% 
  .[order(hryear4, is_baseline, is_post, is_validation)]
```

```{r check on year-month distribution for non-validation, eval = developer_mode}
cps_timing_sub[is_validation == FALSE,
               j = table(year_month, is_baseline)]
```

<!-- ### Develop household composition flags -->

Develop key family measured necessary to determine both poverty status and eligibility for Economic Impact Payments.

```{r consider how to treat individuals with separated status with respect to likely filing status, eval = developer_mode}
# For individuals with separated status, examine the relationship to householder
cps_timing_sub[prmarsta == 6, table(perrp)]
```

<!-- These codes are consistent with being the householder themselves (perrp == 1 | perrp == 2), which is by far the most common, or otherwise the child, parent, grandchild, or "other" relative. In short, because this implies that the head of household has no spouse present for whom `hefaminc` would ostensibly represent a combined income, we treat them as would-be single filers if they had no dependent and HOH filers if they had a dependent. -->

```{r develop family information relevant to calculating adjusted income and poverty status}
# Assigning filing status
## Single - Anyone with prmarsta == 4, 5, 6, 7, and no qualifying child
## MFJ - Anyone with prmarsta == 1, 2, 3
## HOH - Anyone with prmarsta == 4, 5, 6, 7 with qualifying children

# Note on qualifying person: 
## A qualifying person includes but not limited to a qualifying child
## A qualifying child is one's (1) own child, step child, foster child, etc.; (2) (under age 19) OR (under age 24 & a full-time student); (3) (single) OR (married and can be claimed as a dependent)
## Although non-kids (e.g., siblings, parents) can be qualifying persons for determining tax filing status, it is difficult to tell whether non-kids meet the requirements from the data. Since most of the qualifying persons are kids, we only count kids
## See `Qualifying Child` section from https://www.irs.gov/publications/p501#en_US_2022_publink1000220823

# Note on Married Filing
## An individual can file MFJ or MFS if they are married 
## This code assumes MFJ if one is married -- which is reasonable based on the IRS statistics -- According to IRS tax statistics, for tax year 2020, 93.4% of [MFJ+MFS] filed jointly and 6.6% filed separately. 
## Source: (https://www.irs.gov/pub/irs-soi/20in13ms.xls)
cps_family <- 
  cps_timing_sub %>% 
  .[j = `:=`(fam_size                 = .N,
             fam_wgt                  = sum(pwsswgt),
             has_schage_kid_base_flag = 1*(between(prtage, 6, 17)) %>% max(),
             n_own_kids               = sum(perrp == 4 & prtage <= 23),                          # child of head and age under 24
             n_kids_le16              = sum(prtage <= 16),                                       # this counts number of kids living in the household regardless of relationship to the head
             n_kids_le13              = sum(prtage <= 13),
             n_kids_le5               = sum(prtage <=  5),
             n_kids_0to2              = sum(between(prtage, 0, 2)),
             n_kids_3to5              = sum(between(prtage, 3, 5)),
             n_own_kids_le5           = sum(prtage <=  5 & perrp == 4),
             n_own_kids_le16          = sum(prtage <= 16 & perrp == 4),
             n_qual_kids              = sum((prtage < 19 & perrp == 4) | (between(prtage, 19, 23) & perrp == 4 & peschenr == 1)), # this is number of qualifying kids
             spouse_present           = max(perrp == 3)),
             by = .(hryear4, hrmonth, cpsid)] %>% 
  .[j = `:=`(single_filer_flag = perrp %in% 1:2 & prmarsta %in% 4:7 & n_qual_kids == 0, # this is head who is unmarried (single, separated, divorced or widowed) with no qualifying kids
             joint_filer_flag  = perrp %in% 1:2 & prmarsta %in% 1:3,                        # assumed MFJ if married, not considering the case of married, living separately and filing MFS
             hoh_filer_flag    = perrp %in% 1:2 & prmarsta %in% 4:7 & n_qual_kids > 0), # this is head who is unmarried (single, separated, divorced or widowed) with qualifying kids
             by = .(hryear4, hrmonth, cpsid)] %>% 
  .[j = `:=`(has_schage_kid_base = factor(has_schage_kid_base_flag,
                                          levels = 0:1, 
                                          labels = c("No Sch-Age Kid, Base",
                                                     "Has Sch-Age Kid, Base")),
             has_young_kids_base = factor(1*(n_kids_le5 > 0),
                                          levels = 0:1,
                                          labels = c("No Young Kids, Base",
                                                     "1+ Young Kids, Base")))] %>% 
  .[j = `:=`(single_filer_flag = max(single_filer_flag),
             joint_filer_flag  = max( joint_filer_flag),
             hoh_filer_flag    = max(   hoh_filer_flag)),
             by = .(hryear4, hrmonth, cpsid)] %>%
  .[j = filing_status := 
      case_when(single_filer_flag == 1 ~ "single", 
                joint_filer_flag  == 1 ~ "joint",  
                hoh_filer_flag    == 1 ~ "hoh", 
                TRUE                   ~ "other")]

```

<!-- ### Test for family composition -->

```{r tests ..., eval = developer_mode}
# Confirm number of head for each household (should be one)
cps_family_test <- 
  cps_family %>%
  .[j = `:=`(n_hoh = sum(1*(perrp %in% 1:2))),
    by = .(hryear4, hrmonth, year_month, cpsid)]

table(cps_family_test$n_hoh, useNA = "always")

gc(cps_family_test)

```

### Adjustment for Economic Impact Payments

A key measure for development is family income, which at follow-up is used to determine eligibility for programming. The family income measure represented in the basic monthly file, FAMINC, is documented as *"...the total combined income during the past 12 months for all members of the householder's family. The questionnaire says that 'This includes money from jobs, net income from business, farm or rent, pensions, dividends, interest, social security payments and any other money income received' by members of the householder's family who are 15 years of age or older.* From investigation of patterns of income stability and employment status, it seems clear that federal Economic Impact Payments were included in this amount. However, eligibility for child care supports do not include these amounts. **\]Direct citation is necessary.\]**

The first round of federal stimulus was signed on March 27, 2020 and [provided for](https://www.aarp.org/politics-society/advocacy/info-2020/coronavirus-stimulus-checks.html):

* \$1,200 for single adults, and \$2,400 for married
* \$500 for each child under 17
* A 5% reduction in these benefits for every dollar earned over \$75,000 for individual, \$112,500 for heads of household, and \$150,000 for married joint filers /!\\ Note that the source only directly describes the benefit for individuals as reducing according to this schedule

The timing of these payments was not precise. Given a mid-May deadline to submit banking information--after which individuals would receive a paper check rather than direct deposit, the timing of receipt is roughly assumed to be May 2020 although this likely varies meaningfully.

The second round of federal stimulus was signed on March 27, 2020 and [provided for](https://www.aarp.org/money/taxes/info-2020/second-stimulus-checks.html):

* \$600 for single adults, and \$1,200 for married 
* \$600 for each child 16 or younger (/!\\ note that, per the current source, it is ambiguous whether this is the same or different than the previous threshold)
* A 5% reduction in these benefits for every dollar earned over \$75,000 for individual, \$112,500 for heads of household, and \$150,000 for married joint filers /!\\ Note that the source only directly describes the benefit for individuals as reducing according to this schedule

Timing of payment for the second Economic Impact Payment was more tightly controlled than in the first round, and was set for payment on December 30th, 2020. We assume that this income was received as of January 2021.

The third round of federal stimulus was issued starting in March 2021 and [provided for](https://www.aarp.org/money/taxes/info-2021/third-stimulus-checks.html):

* \$1,400 for single adults, and \$2,800 for married
* \$1,400 for each eligible dependent, including adult dependents
* Full amount of the payment for \$75,000 for single filers, \$112,500 for head of household, and \$150,000 for married joint filers. (https://www.irs.gov/coronavirus/third-economic-impact-payment)
* Reduction of amounts with full phase-out at \$80,000 for single filers, \$120,000 for head of household, and \$160,000 for married joint filers. This implied a significantly higher rate of phase-out, and one that is variable (https://www.irs.gov/newsroom/more-details-about-the-third-round-of-economic-impact-payments)
* Removal of age cap -- all qualifying kids (not just under 17) were eligible for the third stimulus check

With some exceptions, the majority of this Economic Impact Payment was sent as of March 30, 2021. We assume that this income was received as of April 2021.

These payments were based on adjusted gross income (AGI) from 2019, or AGI from 2020 for the third payment if households had filed in time for consideration (as presumably it would benefit many households to do so). For simplicity, we assume that income at the baseline month is representative of this basis for determining eligibility.

<!-- /!\ Revisit this -- this can likely be improved, especially considering the third economic payment -->


```{r determine would-be economic impact payments}
cps_family[j = faminc_draw := draw_inc(hefaminc)]

cps_base_income <- 
  cps_family[months_since_base == 0 & perrp %in% 1:2,
             .(cpsid, faminc_draw0 = faminc_draw)]
cps_pov <- 
  cps_family %>% 
  merge(cps_base_income,
        by = "cpsid",
        all.x = TRUE) %>% 

  # Adjust estimates of family income by economic impact payments
  # /!\ Note that we assume that only own children (bio or step) are dependents though
  # it may be worth more care determining alignment with hefaminc which is for the 
  # "householder's family".
  .[j = `:=`(eip1_est = 
               case_when(filing_status == "single" ~ pmax(0, 1200 + n_own_kids_le16*500 - pmax(0, 0.05*(faminc_draw0 -  75000))),
                         filing_status == "hoh"    ~ pmax(0, 2400 + n_own_kids_le16*500 - pmax(0, 0.05*(faminc_draw0 - 112500))),
                         filing_status == "joint"  ~ pmax(0, 2400 + n_own_kids_le16*500 - pmax(0, 0.05*(faminc_draw0 - 150000)))),
             eip2_est = 
               case_when(filing_status == "single" ~ pmax(0,  600 + n_own_kids_le16*600 - pmax(0, 0.05*(faminc_draw0 -  75000))),
                         filing_status == "hoh"    ~ pmax(0, 1200 + n_own_kids_le16*600 - pmax(0, 0.05*(faminc_draw0 - 112500))),
                         filing_status == "joint"  ~ pmax(0, 1200 + n_own_kids_le16*600 - pmax(0, 0.05*(faminc_draw0 - 150000)))),
             eip3_est = 
               case_when(filing_status == "single" & faminc_draw0 < 75000                  ~ 1400*(1 + n_qual_kids),
                         filing_status == "single" & between(faminc_draw0, 75000, 80000)   ~ pmax(0, (5000-(faminc_draw0-75000))/5000*1400*fam_size),
                         filing_status == "single" & faminc_draw0 > 80000                  ~ 0,
                         filing_status == "hoh"    & faminc_draw0 < 112500                 ~ 1400*(2 + n_qual_kids),
                         filing_status == "hoh"    & between(faminc_draw0, 112500, 120000) ~ pmax(0, (7500-(faminc_draw0-112500))/7500*1400*fam_size),
                         filing_status == "hoh"    & faminc_draw0 > 120000                 ~ 0,
                         filing_status == "joint"  & faminc_draw0 < 150000                 ~ 1400*(1 + n_qual_kids),
                         filing_status == "joint"  & between(faminc_draw0, 150000, 160000) ~ pmax(0, (10000-(faminc_draw0-150000))/10000*1400*fam_size),
                         filing_status == "joint"  & faminc_draw0 > 160000                 ~ 0),
             eip1_receipt = between((hryear4 - 2020)*12 + (hrmonth - 5), 0, 11),
             eip2_receipt = between((hryear4 - 2021)*12 + (hrmonth - 1), 0, 11),
             eip3_receipt = between((hryear4 - 2021)*12 + (hrmonth - 4), 0, 11))]
```

```{r check the assignment of eip receipts by filing status, eval = developer_mode}
cps_pov_test <-
  cps_pov %>%
  .[j = `:=`(eip3_thres_full = 
               case_when(filing_status == "single" ~ 80000,
                         filing_status == "hoh"    ~ 120000,
                         filing_status == "joint"  ~ 160000))]
  
cps_pov_test[, 
        .(`1st EIP` = max(eip1_est, na.rm = TRUE),
          `2nd EIP` = max(eip2_est, na.rm = TRUE),
          `3rd EIP` = max(eip3_est, na.rm = TRUE)),
        by = .(filing_status)] %>% 
  kable()

cps_pov_test[faminc_draw0 > eip3_thres_full, 
        .(`3rd EIP` = max(eip3_est, na.rm = TRUE)),
        by = .(filing_status)] %>% 
  kable()

gc(cps_pov_test)
```

```{r check the schedule of eip receipts, eval = developer_mode}
cps_pov[hryear4 >= 2020, 
        .(`Received EIP #1` = max(eip1_receipt), 
          `Received EIP #2` = max(eip2_receipt), 
          `Received EIP #3` = max(eip3_receipt)), 
        by = .(hryear4, hrmonth)] %>% 
  kable()
```

```{r}
# Check whether all values needed for poverty calculations are represented in the
# relevant lookup tables. If not, make the appropriate updates in the 
# `method--general-helper-functions.R` script
cps_fam_sizes <- table(cps_pov$fam_size) %>% prop.table()
cps_faminc_vals <- sort(unique(cps_pov$hefamic))
  # We don't have values for 996, 997, or 999 coded, but these are "refused",
  # "don't know", and "blank" ... thus, they're not codeable

```


```{r develop income to poverty ratio and ccdf/ccap eligibility for cps considering economic impact payments}
cps_pov <-
  cps_pov %>% 
  
  # Remove economic impact payment information to get adjusted family income
  # relevant for program eligibility
  .[j = faminc_draw := draw_inc(hefaminc)] %>%                              #draw family income randomlly
  .[j = faminc_adj_unbounded := faminc_draw - eip1_receipt*eip1_est -
                                              eip2_receipt*eip2_est -
                                              eip3_receipt*eip3_est] %>%    #adjusted family income considering eip
  
  .[j = faminc_adj := pmax(0, faminc_adj_unbounded)] %>% 
  
  # Develop ratios
  merge(fpl_by_month,
        by.x = c("fam_size", "hryear4", "hrmonth"),
        by.y = c("fpl_fam_size", "fpl_year", "fpl_month"),
        all.x = TRUE) %>% 
  .[j = `:=`(fam_incpov_ratio     = faminc_draw / fpl,
             fam_incpov_ratio_adj = faminc_adj  / fpl)] %>% 
  # Bin family income
  .[j = `:=`(fam_incpov_ratio_cat_byMix     = bin_incpov_ratio(fam_incpov_ratio,     pov_breaks = c(0, 0.50, 1.00, 2.00, 3.00, 4.00)),
             fam_incpov_ratio_cat_byMix_adj = bin_incpov_ratio(fam_incpov_ratio_adj, pov_breaks = c(0, 0.50, 1.00, 2.00, 3.00, 4.00)),
             fam_incpov_ratio_cat_to185     = bin_incpov_ratio(fam_incpov_ratio,     pov_breaks = c(0, 0.50, 1.25, 1.85, 3.00, 4.00)),
             fam_incpov_ratio_cat_to185_adj = bin_incpov_ratio(fam_incpov_ratio_adj, pov_breaks = c(0, 0.50, 1.25, 1.85, 3.00, 4.00)),
             fam_incpov_ratio_cat_by50      = bin_incpov_ratio(fam_incpov_ratio,     pov_breaks = seq(0, 4, by = 0.50)),
             fam_incpov_ratio_cat_by50_adj  = bin_incpov_ratio(fam_incpov_ratio_adj, pov_breaks = seq(0, 4, by = 0.50)),
             fam_incpov_ratio_cat_by75      = bin_incpov_ratio(fam_incpov_ratio,     pov_breaks = c(0, 0.75, 1.50, 2.25, 3.00, 4.00)),
             fam_incpov_ratio_cat_by75_adj  = bin_incpov_ratio(fam_incpov_ratio_adj, pov_breaks = c(0, 0.75, 1.50, 2.25, 3.00, 4.00)),
             fam_incpov_ratio_cat_by100     = bin_incpov_ratio(fam_incpov_ratio,     pov_breaks = seq(0, 4, by = 1.00)),
             fam_incpov_ratio_cat_by100_adj = bin_incpov_ratio(fam_incpov_ratio_adj, pov_breaks = seq(0, 4, by = 1.00)),
             fam_incpov_ratio_le.5       = 1*(fam_incpov_ratio     <= 0.5),
             fam_incpov_ratio_le.5_adj   = 1*(fam_incpov_ratio_adj <= 0.5),
             fam_incpov_ratio_le1        = 1*(fam_incpov_ratio     <= 1.0),
             fam_incpov_ratio_le1_adj    = 1*(fam_incpov_ratio_adj <= 1.0),
             fam_incpov_ratio_le1.85     = 1*(fam_incpov_ratio     <= 1.85),
             fam_incpov_ratio_le1.85_adj = 1*(fam_incpov_ratio_adj <= 1.85),
             fam_incpov_ratio_le2        = 1*(fam_incpov_ratio     <= 2.0),
             fam_incpov_ratio_le2_adj    = 1*(fam_incpov_ratio_adj <= 2.0),
             fam_incpov_ratio_le2.25     = 1*(fam_incpov_ratio     <= 2.25),
             fam_incpov_ratio_le2.25_adj = 1*(fam_incpov_ratio_adj <= 2.25),
             fam_incpov_ratio_le4.00     = 1*(fam_incpov_ratio     <= 4.0),
             fam_incpov_ratio_le4.00_adj = 1*(fam_incpov_ratio_adj <= 4.0))]
```

```{r check the correspondence of adjusted and unadjusted hefaminc numbers, eval = developer_mode}
income_adj_plot <- 
  ggplot(cps_pov[hryear4 == 2020 & hrmonth == 9],
         aes(x = faminc_draw,
             y = faminc_draw - faminc_adj,
             color = factor(n_kids_le16))) +
  geom_point(alpha = 0.4) +
  geom_smooth() +
  geom_vline(xintercept = 15e4)
ggplotly(income_adj_plot)
```

<!-- It seems that there is a non-trivial number of households with higher income that are receiving Economic Impact Payments. Note--this is because `hefaminc` is reported categorically with top-coding at \$150,000, which is nearby the relevant cutoff for EIP payments for many families. Thus, some families who qualify for EIP payments based on lagged income may have current income that is above $150k, but which cannot be determined. -->

<!-- The plot function above is noting missing values. Investigating those, it seems that there are missing values in the adjusted measure. -->

```{r detect missings in income measures, eval = developer_mode}
# Check on missing values
cps_pov[, .(income_is_NA     = sum(is.na(faminc_draw)) %>% comma(),
            adj_income_is_NA = sum(is.na(faminc_adj_unbounded)) %>% comma()),
        by = hryear4]
```

<!-- It appears that these are occurring largely as a result of missing baseline income data via the `faminc_draw0` construction. /!\\ This needs to be investigated, as all households should have this information. Some of the subsetting may be responsible. That may be the initial `cps_sub` restriction to lower incomes, which rules out households with higher income at baseline, or perhaps due to restrictions of time. -->

```{r check the overall rate of missingness for baseline family income, eval = developer_mode}
cps_pov[is.na(faminc_adj),
        mean(is.na(faminc_draw0))]
```

<!-- Check the correspondence between adjusted and unadjusted poverty bins. -->

```{r check on correspondence of poverty measures, eval = developer_mode}
cps_pov[hryear4 == 2020, 
        table(fam_incpov_ratio_cat_by100,
              fam_incpov_ratio_cat_by100_adj)]
```

A remaining support available to households during the pandemic is Unemployment Insurance intended to buoy household income during the economic crash. While eligibility for child care programs excludes consideration of the EIPs, it does consider UI benefits as income. Below, we compare our adjusted income measure to that of income plus UI benefits from the CPS's Annual Social and Economic Supplement (ASEC).

 <!-- /!\ Note: look for confirmation/documentation of UI income related to eligibility -->
 <!-- /!\ Note: no longer using ASEC; consider deleting the chunks below -- chunk 20-22 -->

```{r check on the correspondence of adjust basic-monthly income with ASEC wage plus UI, eval = developer_mode}
if (FALSE) {
  comp_sub <- 
  copy(cps_pov) %>% 
  .[ASECFLAG == 1 & YEAR %in% 2020:2021 & MONTH == 3 & INCWAGE != 99999999 & INCUNEMP != 999999 & AGE >= 15] %>% 
  .[j = `:=`(all_inc  = sumNA(INCTOT),
             all_wage = sumNA(INCWAGE),
             all_ui   = sumNA(INCUNEMP),
             n = .N),
    by = CPSID] %>% 
  .[j = `:=`(inc_plus_ui = all_wage + all_ui)] %>% 
  .[j = adj_net_incui := faminc_adj - inc_plus_ui] %>% 
  .[RELATE == 101]

# ggplot(comp_sub,
#        aes(x = faminc_draw,
#            y = all_wage, 
#            color = n)) +
# #  geom_point() +
#   geom_smooth()

ggplot(comp_sub[faminc_adj < 150000],
       aes(x = faminc_adj,
           y = inc_plus_ui,
           color = factor(YEAR))) +
           #y = adj_net_incui)) +
  #geom_point() +
  geom_smooth() +
  geom_abline(intercept = 0,
              slope = 1)
}

```

<!-- From the above, it appears that our adjusted measure is below the calculation of household total wages plus unemployment insurance benefits. Note that we examine only smoothed lines rather than the data, because of the size of outliers. That fact motivates a next examination of smoothed medians rather than means. -->

```{r compare median wage plus ui vs our adjusted measure, eval = developer_mode}
# See this SO forum post for reference: https://stackoverflow.com/questions/65147186/geom-smooth-with-median-instead-of-mean
rolling_median <- function(formula, data, n_roll = 201, ...) {
  x <- data$x[order(data$x)]
  y <- data$y[order(data$x)]
  y <- zoo::rollmedian(y, n_roll, na.pad = TRUE)
  structure(list(x = x, y = y, f = approxfun(x, y)), class = "rollmed")
}

predict.rollmed <- function(mod, newdata, ...) {
  setNames(mod$f(newdata$x), newdata$x)
}

if (FALSE) {
ggplot(comp_sub[faminc_draw < 150000],
       aes(x = faminc_adj,
           y = inc_plus_ui,
           color = factor(YEAR))) +
           #y = adj_net_incui)) +
  #geom_point() +
  geom_smooth(formula = y ~ x, 
              method = "rolling_median", 
              se = FALSE) +
  geom_abline(intercept = 0,
              slope = 1) +
  scale_y_continuous(labels = comma) +
  scale_x_continuous(labels = comma) +
  scale_color_discrete(name = "") +
  labs(title = "ASEC Total Wage + UI is Greater than Adjusted Basic Income",
       subtitle = glue("Trend lines show smoothed median values",
                       "Sample is March 2020 and 2021, Income Summed for HH Members Aged 15+",
                       "Adjusted income below top-coded limit of $150,000"),
       x = "EIP-Adjusted Family Income (Basic Monthly)",
       y = "Summed Wage and UI (ASEC)") +
  myTheme +
  theme(legend.position = "bottom")
}
```

<!-- For completeness, we also compare total family income for the basic monthly and ASEC data. Here, the summed "total income" measure in the ASEC is clearly above that for FAMINC, even at lower incomes where divide/investment/rent etc sources of income are less likely. Checking on definitions: -->

<!-- `FAMINC`, from the basic monthly files, "... includes money from jobs, net income from business, farm or rent, pensions, dividends, interest, social security payments and any other money income received" and is summed for all members of the household who are aged 15 and older. -->

<!-- `INCTOT`, from the ASEC, "indicates each respondent's total pre-tax personal income or losses from all sources for the previous calendar year. Amounts are expressed as they were reported to the interviewer; users must adjust for inflation using Consumer Price Index adjustment factors."  -->

<!-- These definitions do not immediately explain the discrepancy. -->

<!-- We do not believe that there is a specific takeaway for our current exercise as the above comparison of adjusted income to wage and UI benefits roughly correspond, at least at lower incomes. With that said, there would be value to better understand these comparisons to understand how it may be valuable to further adjust our measure of income from the monthly data. -->

```{r examine correspondence of total income, eval = developer_mode}
if (FALSE) {
ggplot(comp_sub[faminc_draw < 150000],
       aes(x = faminc_draw,
           y = all_inc,
           color = factor(YEAR))) +
           #y = adj_net_incui)) +
  #geom_point() +
  geom_smooth(formula = y ~ x, 
              method = "rolling_median", 
              se = FALSE) +
  geom_abline(intercept = 0,
              slope = 1) +
  scale_y_continuous(labels = comma) +
  scale_x_continuous(labels = comma) +
  scale_color_discrete(name = "") +
  labs(title = "ASEC Total Income is Greater than Adjusted Family Income",
       subtitle = glue("Sample is March 2020 and 2021, Income Summed for HH Members Aged 15+\n",
                       "Adjusted income below top-coded limit of $150,000"),
       x = "Family Income (Basic Monthly)",
       y = "Summed Total Income (ASEC)") +
  myTheme +
  theme(legend.position = "bottom")
}
```

### Build CCDF Eligibility Flags

Develop flags for eligibility of child care subsidies through the federal Child Care and Development Fund (CCDF). Locally, the Illinois [Child Care Assistance Program (CCAP)](https://www.dhs.state.il.us/page.aspx?item=30355) is available to families based on criteria that include the following:

* live in the state, 
* are employed and/or attending an eligible educational activity
* have children younger than 13 that need care during the adult work or school hours, or children with documented special needs up to age 19
* have family income below [allowable limits](https://www.dhs.state.il.us/page.aspx?item=118832), representing income below 225% of the federal poverty line for initial eligibility, and below 275% of FPL for 12-month redetermination as of 7/1/22

The [Child Care Assitance Program Policy Manual](https://www.dhs.state.il.us/page.aspx?item=9877) has detail around eligibility, including exempt and non-exempt income.

```{r develop flags for CCDF/CCAP eligibility}
# /!\hk: come back here to determine definition of employed
# Note -- relevant employment status (pemlr) classifications include
# - 1 employed/atwork
# - 12 has job, not at work (potentially?)
# - 32 Not in Labor Force (NILF) unable to work (potentially relevant?)
# - 34 NILF, other -- from description, this includes "other activities attending school or keeping house"
  # ... we may seek corroboration from the education supplement to discriminate between NILF discouraged/keeping house, and NILF attending school/training


#  1 "Employed-At Work"
#  2 "Employed-Absent"
#  3 "Unemployed-On Layoff"
#  4 "Unemployed-Looking"
#  5 "Retired-Not In Labor Force"
#  6 "Disabled-Not In Labor Force"
#  7 "Other-Not In Labor Force"


# In the Education supplement--generally assessed in October, though not in October 21 for some reason (at least in IPUMS records)

cps_ccdf_subset <- 
  cps_family[perrp %in% 1:3 & # subsets to head of household and spouse
               n_kids_le13 >= 1]

# premphrs (reason not at work/hours at work)
# -1      Not in Universe
#	 0	    UNEMPLOYED AND NILF
#	 1	    W/JOB, NOT AT WORK-ILLNESS
#	 2	    W/JOB, NOT AT WORK-VACATION
#	 3	    W/JOB, NOT AT WORK-WEATHER AFFECTED JOB
#	 4	    W/JOB, NOT AT WORK-LABOR DISPUTE
#	 5	    W/JOB, NOT AT WORK-CHILD CARE PROBLEMS
#	 6	    W/JOB, NOT AT WORK-FAM/PERS OBLIGATION
#	 7	    W/JOB, NOT AT WORK-MATERNITY/PATERNITY
#	 8	    W/JOB, NOT AT WORK-SCHOOL/TRAINING
#	 9	    W/JOB, NOT AT WORK-CIVIC/MILITARY DUTY
#	 10	    W/JOB, NOT AT WORK-DOES NOT WORK IN BUS
#	 11	    W/JOB, NOT AT WORK-OTHER
#	 12-22	AT WORK
						
table(cps_ccdf_subset$premphrs, cps_ccdf_subset$pemlr)

cps_ccdf_flags <- 
  cps_ccdf_subset %>% 
  .[j = .(ccdf_elig_tight = min(pemlr %in% c(1, 2)    | peschenr == 1),         # corresponds to at work, with a job but not at work, public school, or private/home school
          ccdf_elig_loose = min(pemlr %in% c(1, 2, 7) | peschenr == 1)),        # adding "other" NILF which could be education or training, or housework
    by = .(hryear4, hrmonth, year_month, cpsid)]

# Examine conditions
if (FALSE) {
  cps_ccdf_check <- 
    merge(cps_ccdf_subset[j = .(year_month, cpsid, perrp, pemlr, premphrs, peschenr)], 
          cps_ccdf_flags, 
          by = c("year_month", "cpsid"))

  View(cps_ccdf_check)
  
  # What's the frequency of other relevant status
  # -1  Not in Universe
  #  1	EMPLOYED-AT WORK
  #  2	EMPLOYED-ABSENT
  #  3	UNEMPLOYED-ON LAYOFF
  #  4	UNEMPLOYED-LOOKING
  #  5	NOT IN LABOR FORCE-RETIRED
  #  6	NOT IN LABOR FORCE-DISABLED
  #  7	NOT IN LABOR FORCE-OTHER
  cps_ccdf_check[, table(pemlr) %>% prop.table() %>% round(2)]
}
```

```{r quick memory cleanup}
rm(cps_timing)
gc()
```


```{r merge ccdf family measures into income}
# Calculate CCDF/CCAP eligibility
cps_elig <- 
  cps_pov %>% 
  merge(cps_ccdf_flags,
        by = c("hryear4", "hrmonth", "year_month", "cpsid"),
        all.x = TRUE) %>% 
  .[j = `:=`(ccdf_elig_tight_inc     = ccdf_elig_tight * (fam_incpov_ratio     <= local_ccdf_thresh/100),
             ccdf_elig_tight_inc_adj = ccdf_elig_tight * (fam_incpov_ratio_adj <= local_ccdf_thresh/100),
             ccdf_elig_loose_inc     = ccdf_elig_loose * (fam_incpov_ratio     <= local_ccdf_thresh/100),
             ccdf_elig_loose_inc_adj = ccdf_elig_loose * (fam_incpov_ratio_adj <= local_ccdf_thresh/100))]
```

```{r Examine rates of cross-classification between Head Start PFA and CCDF, eval = developer_mode}
cps_elig[j = .(n = comma(.N)), 
         by = .(#fam_incpov_ratio_cat_by100,
                fam_incpov_ratio_cat_by100_adj,
                #ccdf_elig_tight_inc,
                ccdf_elig_tight_inc_adj,
                ccdf_elig_loose_inc_adj)] %>% 
  .[order(fam_incpov_ratio_cat_by100_adj)]
```

### CPS Baseline Measures

Relevant measures at baseline, when households first enter the CPS:

* Presence population of interest, specifically being aged 0-5, and residence in metro area
* Age group, within ages 0-5
* Detailed category of income-to-poverty ratio
* Vulnerability of head-of-household's industry, if working
* Other categories--e.g. race, education--of often-relevant context

```{r develop baseline vulnerability characteristics -- cps head of household}
cps_hoh <- 
  cps_elig %>%
  .[perrp %in% 1:2] %>%
  .[j =  `:=`(hoh_gender = case_when(pesex == 1 ~ "male", 
                                     pesex == 2 ~ "female"),
              hoh_race = case_when(ptdtrace == 1 ~ "white",
                                   ptdtrace == 2 ~ "black", 
                                   TRUE ~ "other_multiple"),
              hoh_hispanic  = 1 - 1*(pehspnon == 2),
              hoh_industry  = bin_industry(peio1icd),
              hoh_empl      = 1*(pemlr == 1),
              hoh_educ      = case_when(between(peeduca, 31, 38) ~ "less_hs", 
                                        peeduca == 39            ~ "hs", 
                                        between(peeduca, 40, 42) ~ "somecoll", 
                                        peeduca == 43            ~ "coll",
                                        between(peeduca, 44, 46) ~ "collplus", 
                                        TRUE                     ~ ""))] %>% 
  .[j = `:=`(hoh_industry_vulnerable = ifelse(hoh_industry == "NA", 
                                              "NA", 
                                              str_detect(hoh_industry, "educhealth|food")),
             fhoh_empl = factor(hoh_empl,
                                levels = 0:1, 
                                labels = c("HOH Not Employed",
                                           "HOH Employed")))] %>% 
  dplyr::select(cpsid, months_since_base, hoh_gender, hoh_educ, hoh_race, hoh_hispanic, hoh_industry, hoh_industry_vulnerable, hoh_empl)

cps_base_hoh <- cps_hoh[months_since_base ==  0] %>% dplyr::select(-months_since_base)
cps_post_hoh <- cps_hoh[months_since_base == 15] %>% dplyr::select(-months_since_base)
```


```{r check on the correspondence of baseline and post measures, eval = developer_mode}
dim(cps_base_hoh); dim(cps_post_hoh)
cps_base_hoh <- unique(cps_base_hoh)
cps_post_hoh <- unique(cps_post_hoh)
# /!\ Not sure why these `unique()` operations matter, but they do. Perhaps some upstream merge.
dim(cps_base_hoh); dim(cps_post_hoh)
# /!\ dimension seems a bit off compared to CPS-IPUMS -- something to do with months_since_base in CPS-IPUMS?
```


```{r develop child-level measures}
# Note that this is at the child-level with relevant family information merged
# to each child's record. It is in the the custom model-run specifications that 
# we aggregate to the household level.

# /!\ We should obtain weights that are as of baseline. Here and in the 
# calculations below we are only pulling final weights.

cps_child_base <- 
  cps_elig[is_baseline == TRUE & between(prtage, 0, local_kid_age_thres+1)] %>%   #add 1 to the threshold to give more flexibility
  .[j = .(cpsid, cpsidp, pwsswgt, hwhhwgt, 
          hryear4, hrmonth, year_month, prtage, is_validation, metro, 
          child_agegroup = bin_age(prtage),
          has_schage_kid_base,
          n_kids_le5,
          spouse_present,
          ccdf_elig_tight, ccdf_elig_loose,
          fSpouse_present = factor(spouse_present,
                                   levels = 0:1, 
                                   labels = c("No Spouse Present, Base",
                                              "Spouse Present, Base")),
          faminc_adj, fam_incpov_ratio,
          fam_incpov_ratio_cat_by50,  fam_incpov_ratio_cat_by50_adj, 
          fam_incpov_ratio_cat_by75,  fam_incpov_ratio_cat_by75_adj,
          fam_incpov_ratio_cat_by100, fam_incpov_ratio_cat_by100_adj,
          fam_incpov_ratio_cat_to185, fam_incpov_ratio_cat_to185_adj)] %>% 
  merge(cps_base_hoh,
        by = "cpsid",
        all.x = TRUE)
```

```{r confirm child-level base has multiple children per household}
cps_child_base[j = .(n = .N), by = cpsid] %>% 
    .[, table(n)]
```


### CPS Post Measures

Relevant measures:

* Head Start eligibility -- income-to-poverty ratio < 1.0
* PFA eligibility -- income-to-poverty ratio < 2.0
* CCAP eligibility -- income-to-poverty and parent work/school eligibility

```{r develop follow-up program eligibility -- cps}

# Whereas before we kept this data at the child level, we now preserve it as
# functionally household-level indicators, by preserving just the record of the
# householder which has household-level (and some select hoh) measures. 
# This prevents a many-to-many merge to the cps_child_base which is at the 
# child-level.
cps_post <-
  cps_elig[is_post == TRUE & perrp %in% 1:2 & months_since_base == 15,
           j = .(cpsid,
                 hryear4, hrmonth, hwhhwgt, is_validation,
                 faminc_adj, fam_incpov_ratio,
                 hoh_empl_post = 1*(pemlr == 1),                         #/!\hk: come back here to determine work eligibility
                 incpov_le50_post  = fam_incpov_ratio_le.5,
                 incpov_le100_post = fam_incpov_ratio_le1,
                 incpov_le185_post = fam_incpov_ratio_le1.85,
                 incpov_le200_post = fam_incpov_ratio_le2,
                 incpov_le225_post = fam_incpov_ratio_le2.25,
                 incpov_le400_post = fam_incpov_ratio_le4.00,
                 incpov_le50_post_adj  = fam_incpov_ratio_le.5_adj,
                 incpov_le100_post_adj = fam_incpov_ratio_le1_adj,
                 incpov_le185_post_adj = fam_incpov_ratio_le1.85_adj,
                 incpov_le200_post_adj = fam_incpov_ratio_le2_adj,
                 incpov_le225_post_adj = fam_incpov_ratio_le2.25_adj,
                 incpov_le400_post_adj = fam_incpov_ratio_le4.00_adj,
                 ccdf_elig_tight_inc, ccdf_elig_tight_inc_adj,
                 ccdf_elig_loose_inc, ccdf_elig_loose_inc_adj)]
dim(cps_post)
cps_post <- unique(cps_post)
dim(cps_post)
# /!\ Not sure why this unique() operation is needed, but it is. Perhaps some upstream merge?
```

```{r clean up files}
# rm(cps_sub, cps_timing, cps_timing_sub, cps_pov)
gc()
```

Check the correspondence between `cps_post` and `cps_base`.

```{r check that post IDs are found in base, eval = developer_mode}
cps_child_base[hryear4 == 2019 & hrmonth == 1, 
               .(pct_base_in_post        = mean(cpsid %in% cps_post$cpsid)
                 # pct_post_in_pov         = mean(cpsid %in% cps_pov$cpsid), 
                 # pct_post_in_pov_monthly = mean(cpsid %in% cps_pov_monthly$cpsid), 
                 # pct_base_in_raw         = mean(cpsid %in% cps$cpsid)
                 ), 
               by = .(hryear4, hrmonth)]
```


<!-- ### Evaluate CPS Patterns of Income Transition -->

<!-- Some of this may be appropriate to examine as part of the implementation of the now-casting, rather than at the stage of data development -->

```{r develop a data set with pre-post comparisons for heads of household}
cps_hoh_pre_post <- 
  merge(cps_elig[perrp %in% 1:2 & faminc_draw < 150000 & months_since_base ==  0] %>% unique(), # & year_month == "2019-06"],
        cps_elig[perrp %in% 1:2 & faminc_draw < 150000 & months_since_base == 15] %>% unique(), # & year_month == "2020-09"],
        by = "cpsidp",
        #all = TRUE,
        suffixes = c("_b", "_p")) %>% 
  #dplyr::select(-months_since_base_b, -months_since_base_p) %>% 
  merge(cps_base_hoh, by.x = "cpsid_b", by.y = "cpsid", all.x = TRUE) %>% 
  merge(cps_post_hoh, by.x = "cpsid_b", by.y = "cpsid", all.x = TRUE, suffixes = c("_b", "_p"))

cps_hoh_pre_post[j = `:=`(stayed_unemp = !hoh_empl_b & !hoh_empl_p,
                          stayed_emp   =  hoh_empl_b &  hoh_empl_p,
                          started_emp  = !hoh_empl_b &  hoh_empl_p,
                          stopped_emp  =  hoh_empl_b & !hoh_empl_p)] %>% 
  .[j = `:=`(emp_traj = case_when(stayed_unemp ~ "stayed_unemp",
                                  stayed_emp   ~ "stayed_emp",
                                  started_emp  ~ "started_emp",
                                  stopped_emp  ~ "stopped_emp"))]

cps_hoh_pre_post[j = hoh_educ_b := factor(hoh_educ_b, levels = c("less_hs", "hs", "somecoll", "coll", "collplus"))]

save(cps_hoh_pre_post,
     file = glue("{output_path}CPS pre-post data for heads of household.Rda"))
```


```{r compare head of household incomes at pre and post, eval = developer_mode}
ggplot(cps_hoh_pre_post[hryear4_b == 2019],
       aes(faminc_draw_b,
           faminc_draw_p)) +
  geom_point(alpha = 0.2) + 
  geom_45(color = "blue", 
          linewidth = 1) +
  geom_smooth(color = "red")
```

```{r examine income dynamics by race and presence of young children, eval = developer_mode, fig.height = 6}
ggplot(cps_hoh_pre_post[j = is_black := ifelse(ptdtrace_b == 2, "black HOH", "non-black HOH")],
       aes(faminc_draw_b,
           faminc_draw_p,
           color = has_young_kids_base_b)) +
  # geom_point(alpha = 0.1) + 
  facet_grid(paste0("Base: ", hryear4_b) ~ is_black) +
  geom_45(color = "blue", 
          linewidth = 1) +
  geom_smooth(se = FALSE) +
  scale_color_manual(name = "",
                     values = c("green", "purple")) +
  scale_x_continuous(label = comma) +
  scale_y_continuous(label = comma) +
  labs(title = "Changes in Family Income Between Baseline and Post",
       subtitle = "Family income is random draws from within the `hefaminc` intervals",
       x = "Family income at base",
       y = "Family income at post") +
  theme_minimal()
```

<!-- An interesting piece of evidence here is that lower-educated households had very challenging trajectory around the 2008 financial crisis, but not at the time of the COVID-19 pandemic. That is consistent with our sense of complicated economic opportunity, where essential and gig economy work may have been sustained or expanding. -->

```{r examine income dynamics by education, eval = developer_mode, fig.height = 6}
ggplot(cps_hoh_pre_post[j = ed_lt12 := ifelse(peeduca_b < 39, "Less than HS", "HS or more")],
       aes(faminc_draw_b,
           faminc_draw_p,
           color = has_young_kids_base_b)) +
  # geom_point(alpha = 0.1) + 
  facet_grid(paste0("Base: ", hryear4_b) ~ ed_lt12) +
  geom_45(color = "blue", 
          linewidth = 1) +
  geom_smooth(se = FALSE) +
  scale_color_manual(name = "",
                     values = c("green", "purple")) +
  scale_x_continuous(label = comma) +
  scale_y_continuous(label = comma) +
  labs(title = "Changes in Family Income Between Baseline and Post",
       subtitle = "Family income is random draws from within the `hefaminc` intervals",
       x = "Family income at base",
       y = "Family income at post") +
  theme_minimal()
```

```{r merge post into base}
cps_trans <- 
  merge(cps_child_base,
        cps_post,
        by = c("cpsid"),
        suffixes = c("_b", "_p"),
        all.x = TRUE)
```

<!-- Compare adjusted incomes directly. Lots of noise here. This is the whole sample. -->

```{r compare incomes, eval = developer_mode}
ggplot(cps_trans,
       aes(x = faminc_adj_b,
           y = faminc_adj_p)) +
  geom_point(alpha = 0.1) + 
  geom_45(color = "blue", 
          linewidth = 1) +
  geom_smooth(color = "red")
```

<!-- Focusing on base year 2019, some notes: -->

<!-- 1. smoothed fit lies very close to the 45 -->
<!-- 2. the decrease in incomes at the high end of base seems mechanically related to the ceiling, where income can only go down -->
<!-- 3. there's a surprising amount of scatter. How much of this is real, and how much might be a mismatch? -->

<!-- Takeaway -- seems like there's something upstream that is an issue. -->

```{r compare incomes with a baseline year of 2019, eval = developer_mode}
ggplot(cps_trans[hryear4_b == 2019],
       aes(x = faminc_adj_b,
           y = faminc_adj_p)) +
  geom_point() + 
  geom_45(color = "blue", 
          linewidth = 1) +
  geom_smooth(color = "red")

ggplot(cps_trans[hryear4_b == 2019],
       aes(x = fam_incpov_ratio_b,
           y = fam_incpov_ratio_p)) +
  geom_point() + 
  geom_45(color = "blue", 
          linewidth = 1) +
  geom_smooth(color = "red")
```

<!-- Select examples for investigation. These may not be representative income-wise, but may uncover systematic matching issues. -->

```{r select cases of income mismatch, eval = developer_mode}
cps_trans_low_high <- 
  cps_trans[faminc_adj_b < 10000 & 
            faminc_adj_p > 50000]
```

<!-- Relatively even across base years. -->

```{r are these associated with particular years, eval = developer_mode}
cps_trans_low_high[, table(hryear4_b)]
```

```{r function for examining family circumstances, eval = developer_mode}
examine_case <- function(n) {
  cps[cpsid == cps_trans_low_high[hryear4_b == 2019]$cpsid %>% .[n],
    .(hryear4, hrmonth, cpsid, cpsidp, pulineno, perrp, prtage, pesex, prempnot, pemlr, hefaminc)] %>% 
  .[order(cpsidp)]  %>% 
    View()
}
```

```{r, eval = developer_mode}
# This is a family with two kids, an unmarried partner, and new income as of month 2.
examine_case(1)
```

```{r, eval = developer_mode}
# Three kids, unmarried partner who works generally throughout, but only really starts reporting income later
examine_case(2)
```

```{r, eval = developer_mode}
# Spouse of HOH is periodically working, but makes decent income. Family includes adult children and grandchildren.
examine_case(10)
```

```{r, eval = developer_mode}
# Middle-aged head of household has younger spouse, own young children, and grandchild (together with presence of older child). Both HOH and spouse work consistently, but jumped from minimal household income (below $1k) at baseline to strong earnings (\$75k-\$100k) in later months. Perhaps a reporting issue?

examine_case(40)
```

<!-- Overall, it seems that these are not linkage issues. -->

<!-- ### Investigate the Link of Base to Post --------------------------------->

<!-- Both pre and post are subset to only ages 0-5. That's probably more restrictive than we need, especially since we may want to examine economic dynamics of families with children up through age 17. -->

<!-- Also--it's critical to merge families first and then subset. We want to start with families in post that are eligible, and match them to themselves in base. Some children may not have been born in pre. -->

```{r are we only getting children, eval = developer_mode}
cps_trans[, summary(prtage)]
```

<!-- Perhaps surprisingly, there's often a single child under 5. About 32% of households have more than 1. That sounds unreasonable. -->

```{r how many individuals per CPSID, eval = developer_mode}
n_distinct_ids <- 
  cps_trans[, .(n_in_cpsid = n_distinct(cpsidp)),             #n_in_cpsid: # of distinct kids under {age_thres} within each household
            by = cpsid]
summary(n_distinct_ids)

n_distinct_ids[, .(pct_gt1_child05 = mean(n_in_cpsid > 1))]   #/!\hk: cps_trans subsets data to kids under 14. This calculates percent of households that have more than 1 kid under 14, not under 6?
```

```{r, eval = developer_mode}
cps_child_base[, .(n = .N), by = CPSID] %>% 
  with(table(n) %>% prop.table() %>% round(3))
```

<!-- This earlier construction suggests that cases were dropped along the way. -->

```{r examine counts of young children conditional on at least one, eval = developer_mode}
cps_family[AGE <= 5 & months_since_base == 0, .(CPSID, n_kids_le5)] %>% 
  with(table(n_kids_le5) %>% prop.table() %>% round(3))
```

<!-- Use own kids instead of nkids in the household. -->

```{r examine counts of young children conditional on at least one, using own kids only, eval = developer_mode}
cps_family[AGE <= 5 & months_since_base == 0, .(CPSID, n_own_kids_le5)] %>% 
  with(table(n_own_kids_le5) %>% prop.table() %>% round(3))
```

<!-- Is the issue in how we are calculating things? -->

```{r, eval = developer_mode}
cps_trans[, .(sum(AGE <= 5)), by = CPSID] %>% 
  summary()

cps_family[AGE <= 5 & months_since_base == 0, .(n = .N), by = CPSID] %>% 
  summary()
```

<!-- ## Investigate Pandemic-Era Economic Dynamics for Lower-Income Earners -->

<!-- ### Which subgroups have employment stabilized or increased during the pandemic -->

<!-- Our hypothesis is that, in addition to white collar workers, lower-income households had either protection or a boon during to the pandemic through a combination of essential work, and increased reliance on gig workers for personal shopping, delivery, groceries etc. -->

```{r generate function to examine post-period employment, eval = developer_mode}
examine_empl_post <- function(by_var, by_label) {
  cps_hoh_pre_post[#YEAR_b == 2019,
                   j = .(n = sum(HWTFINL_b),
                         sample_n = .N,
                         empl_at_post = meanNA(hoh_empl_p)),
                   by = c("YEAR_b", "hoh_empl_b", by_var)] %>% 
    .[!is.na(get(by_var))] %>% 
    ggplot(aes(x = factor(hoh_empl_b, 
                          levels = 0:1, 
                          labels = c("Not Empl at Base", "Empl at Base")),
               y = empl_at_post,
               fill = as.factor(get(by_var)))) +
    geom_bar(stat = "identity",
             position = "dodge") +
    # geom_text(aes(label = comma(sample_n)),
    #               position = position_dodge(width = .9),
    #           vjust = 1) +
    facet_wrap(~ paste0("Baseline Year: ", YEAR_b)) +
    scale_fill_discrete(name = by_label) +
    #scale_fill_discrete(name = "") +
    scale_y_continuous(labels = percent,
                       breaks = seq(0, 1, by = 0.2)) +
    labs(title = glue("Post-Period Employment by Baseline Employment, by {by_label}"),
         x = "",
         y = "Employed at Post") +
    theme_minimal() +
    theme(legend.position = "bottom")
}
```

```{r examine post-period employment by baseline education level, eval = developer_mode}
examine_empl_post("hoh_educ_b", "Baseline Education")
```

<!-- Takeaway: lower-income heads of household are not more likely to gain employment if they don't have it, and are less likely to keep it than higher-income heads of household. -->

```{r examine post-period employment by baseline poverty band, eval = developer_mode}
examine_empl_post("fam_incpov_ratio_cat_by100_b", "Baseline Poverty Status")
```

```{r examine post-period employment by presence of spouse, eval = developer_mode}
examine_empl_post("spouse_present_b", "Presence of Spouse at Base")
```

<!-- ### Which industries may have picked up during the pandemic? ------------->

<!-- Takeaways --  -->

<!-- * Lowest-income heads-of-household are most likely to leave work in just about each industry -->
<!-- * The greatest differentials are in finance, construction, manufacturing, other services -->

```{r which industries did people leave, eval = developer_mode}
cps_hoh_pre_post[YEAR_b == 2019 & hoh_empl_b == TRUE,
                 j = .(pct_leaving = mean(1 - hoh_empl_p)),
                 by = .(fam_incpov_ratio_cat_by100_b, hoh_industry_b)] %>% 
  ggplot(aes(x = fam_incpov_ratio_cat_by100_b,
             y = pct_leaving,
             fill = fam_incpov_ratio_cat_by100_b)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_wrap(~ hoh_industry_b,
             scales = "free") +
  scale_y_continuous(labels = percent) +
  scale_fill_discrete(name = "Income-to-Pov Ratio, at Base") +
  labs(title = "Percent of Workers that Become Unemployed, by Baseline Income and Baseline Industry",
       x = "",
       y = "Pct Leaving Industry") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

<!-- Takeaways: -->

<!-- * Heads of household who were lower-income at baseline are clearly over-represented in both arts/food services, both in industries they'd been in, as well as those for new employees -->
<!-- * These same HOHs are under-represented in public administration and wholesale trade -->

<!-- There's a curious pattern here where, above, lower-income HOHs have the highest rate of unemployment coming from, say, food services, and also have the most over-representation here among those who stayed employed. This could be explained by HOHs switching into these industries. -->

```{r which industries did people enter, eval = developer_mode}
cps_hoh_pre_post[YEAR_b == 2019 & hoh_empl_p == TRUE,
                 j = .(n = .N),
                 by = .(fam_incpov_ratio_cat_by100_b, hoh_empl_b, hoh_industry_p)] %>% 
  .[j = pct_in_indust_post := n / sum(n),
    by = .(fam_incpov_ratio_cat_by100_b, hoh_empl_b)] %>% 
  ggplot(aes(x = factor(hoh_empl_b, 
                        levels = 0:1,
                        labels = c("Not Empl at Base", 
                                   "Empl at Base")),
             y = pct_in_indust_post,
             fill = fam_incpov_ratio_cat_by100_b)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_wrap(~ hoh_industry_p,
             scales = "free") +
  scale_y_continuous(labels = percent) +
  scale_fill_discrete(name = "Income-to-Pov Ratio, at Base") +
  labs(title = "Percent of Workers in Industry, by Baseline Income and Baseline Employment Status",
       x = "",
       y = "Pct in Industry") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

<!-- Look again at poverty transitions -->

```{r, eval = developer_mode}
cps_hoh_pre_post[#YEAR_b %in 2019,
                 j = .(n = sum(HWTFINL_b)),
                 by = .(YEAR_b, fam_incpov_ratio_cat_by100_adj_b, fam_incpov_ratio_cat_by100_adj_p)] %>% 
  .[j = pct_in_pov_band := n / sum(n),
    by = .(YEAR_b, fam_incpov_ratio_cat_by100_adj_b)] %>% 
  ggplot(aes(x = fam_incpov_ratio_cat_by100_adj_b,
             y = pct_in_pov_band,
             fill = fam_incpov_ratio_cat_by100_adj_p)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  scale_y_continuous(labels = percent,
                     limits = c(0, 1),
                     breaks = seq(0, 1, by = .20)) +
  scale_fill_discrete(name = "Poverty Band - Post") +
  facet_wrap(~ YEAR_b) +
  labs(x = "Poverty Band - Baseline",
       y = "% in Post Income Band") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r}
save(cps_child_base, cps_post,
     file = glue("{output_path}cps_data.Rda"))
```
