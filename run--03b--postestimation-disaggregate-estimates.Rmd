
```{r}
# run scripts for necessary packages and objects as necessary
if (!"meanNA"        %in% objects()) source("settings--main.R", echo = FALSE)
if (!"my_state_abbr" %in% objects()) source("settings--config.R", echo = FALSE)
if (!"bin_age"       %in% objects()) source("method--general-helper-functions.R", echo = FALSE)
```

```{r load the data from the previous stage}
# Load prepped data
for (f in c("geo", "acs1", "cps", "acs5", "pop")) {
  load(file = glue("{output_path}{f}_data_{my_output_tag}.Rda"))
}
load(file = glue("{output_path}Now-cast counts at the tract level, pre-disaggregation - {my_output_tag}.Rda"))
```


### Disaggregate Estimates by Age Group

Our strategy to disaggregate estimates by age group--primarily to break our estimates for ages 0-5 into 0-2 and 3-5--is to take the empirical age breakdown specific to each outcome, from the ACS 1-year data. 

```{r calculate outcome-specific age breakdowns}
calc_breakdown <- function(acs1_outcome_sub, outcome_var) {
  acs1_age_breakdown <-
    acs1_outcome_sub %>% 
    filter(child_agegroup %in% c("0to2", "3to5")) %>% 
    mutate(age_0to2 = between(AGEP, 0, 2),
           age_3to5 = between(AGEP, 3, 5),
           age_4    = AGEP == 4,
           age_5    = AGEP == 5) %>% 
    summarize(age_0to2 = sum(PWGTP[age_0to2]) / sum(PWGTP),
              age_3to5 = sum(PWGTP[age_3to5]) / sum(PWGTP),
              age_4    = sum(PWGTP[age_4])    / sum(PWGTP),
              age_5    = sum(PWGTP[age_5])    / sum(PWGTP)) %>% 
    mutate(outcome_var = outcome_var)
      
  if (FALSE) {
    acs1_outcome_sub %>% 
      filter(child_agegroup %in% c("0to2", "3to5")) %>% 
      mutate(age_0to2 = between(AGEP, 0, 2),
             age_3to5 = between(AGEP, 3, 5),
             age_4    = AGEP == 4,
             age_5    = AGEP == 5) %>% 
      select(AGEP, child_agegroup, age_0to2, age_3to5, age_4, age_5) %>% 
      unique() %>% 
      arrange(AGEP)
  }
  
  return(acs1_age_breakdown)
}

age_breakdown_byoutcome <-
 bind_rows(
   calc_breakdown(acs1_child %>% filter(fam_incpov_ratio <= 0.50), "incpov_le50_post_adj"),
   calc_breakdown(acs1_child %>% filter(fam_incpov_ratio <= 1.00), "incpov_le100_post_adj"),
   calc_breakdown(acs1_child %>% filter(fam_incpov_ratio <= 1.85), "incpov_le185_post_adj"),
   calc_breakdown(acs1_child %>% filter(fam_incpov_ratio <= 2.00), "incpov_le200_post_adj"),
   calc_breakdown(acs1_child %>% filter(fam_incpov_ratio <= 2.25), "incpov_le225_post_adj"),
   calc_breakdown(acs1_child %>% filter(fam_incpov_ratio <= 4.00), "incpov_le400_post_adj"))
```


```{r add breakdowns for all relevant ccdf sensitivities}

for (ccdf_spec in unique(str_subset(nowcast_parallel_counts$outcome_var, "ccdf_elig_incratio"))) {
  
  age_breakdown_byoutcome <- 
    bind_rows(age_breakdown_byoutcome,
              calc_breakdown(acs1_child %>% filter(get(ccdf_spec) == TRUE),
                             ccdf_spec))
  
} 
```

```{r examine the age dispersion across outcomes, eval = developer_mode}

age_breakdown_byoutcome_long <- 
  age_breakdown_byoutcome %>% 
  pivot_longer(cols = -outcome_var,
               names_to = "child_agegroup",
               values_to = "pct_age_of_0to5") %>%
  mutate(outcome_var = sort_by_char_nums(outcome_var))

plot_age_in_outcome <- function(outcome_regex, subtitle) {
  ggplot(age_breakdown_byoutcome_long %>% filter(str_detect(outcome_var, outcome_regex)),
       aes(x = child_agegroup,
           y = pct_age_of_0to5,
           fill = outcome_var)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  scale_y_continuous(labels = percent) + 
  scale_fill_viridis_d(option = "H",
                       direction = -1) +
  labs(title = "Percent of Children Under 5 by Sub-Age Group, by Outcome",
       subtitle = subtitle,
       x = "",
       y = "% of children <= 5 in group") +
  theme_minimal() +
  theme(legend.position = "bottom")
}

plot_age_in_outcome("incpov", "Income-to-Poverty Outcomes")
plot_age_in_outcome("ccdf",   "CCDF Outcomes")
```

```{r merge and disaggregate tract-level estimates}
# Round age values to ensure adding-up
nowcast_parallel_counts <- 
  nowcast_parallel_counts %>% 
  mutate(count = round(count, 0)) %>% 
  data.table()

# Prep overall population for under 5 breakdown
pop_by_age_0to5 <- 
  pop_by_age %>% 
  select(GEOID = GEOID_TR20, year, age_0to2 = age_0to2_count, age_3to5 = age_3to5_count, age_4 = age_4_count) %>% 
  pivot_longer(cols = matches("age"),
               names_to = "child_agegroup",
               values_to = "pop_count")

nowcast_elig_counts_0to5 <- 
  nowcast_parallel_counts %>% 
  filter(age == "age_0to5") %>% 
  merge(age_breakdown_byoutcome_long,
        by = "outcome_var",
        all.x = TRUE,
        allow.cartesian = TRUE) %>% 
    select(-pop_count) %>% 
  merge(pop_by_age_0to5,
        by = c("GEOID", "year", "child_agegroup"),
        all.x = TRUE) %>% 
  mutate(count    = pct_age_of_0to5 * count,
         count_se = pct_age_of_0to5 * count_se) %>% 
  select(-age, age = child_agegroup)

nowcast_elig_counts_added_ages <- 
  bind_rows(nowcast_elig_counts_0to5,
            nowcast_parallel_counts) %>% 
  select(outcome_var, GEOID, cps_base_recency, pd, year, age, share, share_se, count, count_se, pop_count, pop_count_se) %>% 
  arrange(outcome_var, GEOID, pd, age) %>% 
  data.table()

```

```{r reallocate a portion of five year olds to the school-aged group}
kindy_cutoff <- ifelse(exists("kindergarten_date_cutoff"), 
                       kindergarten_date_cutoff,
                       "09-01")

age5_sch_age_portion <- 
  (ymd(glue("{base_year+1}-{kindy_cutoff}")) - ymd(glue("{base_year+1}-01-01"))) / 365.25
  
age5_sch_age_portion <- as.numeric(age5_sch_age_portion)

age5_portion <- 
  nowcast_elig_counts_added_ages %>% 
  filter(age == "age_5") %>% 
  mutate(count_to_move = age5_sch_age_portion * count,
         se_to_move    = age5_sch_age_portion * count_se,
         var_to_move   = se_to_move^2)

nowcast_elig_counts_final <- 
  nowcast_elig_counts_added_ages %>% 
  merge(age5_portion %>% select(GEOID, outcome_var, cps_base_recency, pd, year, count_to_move, var_to_move),
        by = c("GEOID", "outcome_var", "cps_base_recency", "pd", "year"),
        all.x = TRUE) %>% 
  mutate(count_upd    = case_when(str_detect(age, "3to5|0to5") ~ count - count_to_move,
                                  str_detect(age, "6to12")     ~ count + count_to_move,
                                  TRUE                         ~ count),
         count_se_upd = case_when(str_detect(age, "3to5|0to5") ~ sqrt(count_se^2 - var_to_move),
                                  str_detect(age, "6to12")     ~ sqrt(count_se^2 + var_to_move),
                                  TRUE                         ~ count_se))
```


```{r check on reallocation of a portion of five year olds to the school-aged group, eval = developer_mode}

nowcast_elig_counts_final %>% 
  filter(outcome_var == outcome_var[1],
         cps_base_recency == cps_base_recency[1],
         pd == "nowcast") %>% 
  ggplot(aes(x = count,
             y = count_upd - count)) +
  facet_wrap(~age,
             scales = "free") +
  geom_point()
```


```{r complete reallocation of a portion of five year olds to the school-aged group}
nowcast_elig_counts_final <- 
  nowcast_elig_counts_final %>% 
  select(-count, -count_se) %>% 
  rename(count    = count_upd,
         count_se = count_se_upd)
```


### Aggregate Estimates to Larger Geographies

```{r function to add level of aggregation if not already available}
add_agg_level <- function(ests, agg_level) {
  
  if (!agg_level %in% colnames(ests)) {
    if (agg_level == "ZCTA") {
      geo_merge_data <- 
        geo_crosswalk_zcta %>% 
        transmute(GEOID    = GEOID, 
                  ZCTA     = ZCTA,
                  geo_part = TRLANDPCT)
    } else if (agg_level == "School") {
      geo_merge_data <-
        geo_crosswalk_sd %>%
        transmute(GEOID    = GEOID,
                  School   = school,
                  geo_part = pct_sd)
    } else if (agg_level == "aux_geo_label") {
      geo_merge_data <- 
        geo_crosswalk_aux %>% 
        transmute(GEOID         = GEOID, 
                  aux_geo_label = aux_geo_label, 
                  geo_part      = pct_area)
    } else {
      geo_merge_data <- 
        geo_crosswalk[j = c("GEOID", agg_level), with = FALSE] %>% 
        unique() %>% 
        .[j = geo_part := 1]
    }
    ests <- 
      ests %>% 
      # Note: while merge() is typically used throughout this codebase, we use
      # left_join() here because we have a less-common situation of a large
      # many-to-many merge e.g. in the case of merging to zip codes, where there
      # are many duplicates of GEOID in `ests` because of outcome variable, age
      # and time repeats, as well as in `geo_merge_data` given that tracts often
      # do span multiple zip codes. The `allow.cartesian=TRUE` option in merge()
      # was yielding incorrect and puzzling results.
      left_join(geo_merge_data,
                by = "GEOID") %>% 
      data.table()
  }
  
  if (!"geo_part" %in% colnames(ests)) {
    ests <- mutate(ests, geo_part = 1)
  }
  
  return(ests)
}
```


```{r create function to aggregate tract estimates to higher levels}
agg_tracts_up <- function(ests, agg_level) {
  ests %>%
    add_agg_level(agg_level) %>% 
    .[j = .(count        = sumNA(pop_count*share*geo_part),
            count_se     = se_sum(se_product(pop_count*geo_part, share, pop_count_se*geo_part, share_se)),
            pop_count    = sumNA(pop_count*geo_part),
            pop_count_se = se_sum(pop_count_se*geo_part)),
      by = c(agg_level, "age", "pd", "outcome_var", "cps_base_recency")] %>% 
    mutate(share    = count / pop_count,
           share_se = se_proportion(count, pop_count, count_se, pop_count_se))
}
```

```{r implement various levels of geographic aggregation}
# Note -- ZCTA and "aux" calculations may produce a "Detected an unexpected
# many-to-many relationship between `x` and `y`." This is expected, given 
# how this is a feature of crossing geographies.

nowcast_agg_tract <- agg_tracts_up(nowcast_elig_counts_final, "GEOID")
nowcast_agg_zip   <- agg_tracts_up(nowcast_elig_counts_final, "ZCTA")
nowcast_agg_cty   <- agg_tracts_up(nowcast_elig_counts_final, "County")
nowcast_agg_sd    <- agg_tracts_up(nowcast_elig_counts_final, "School")

if (exists("my_aux_geo")) {
  nowcast_agg_aux <- agg_tracts_up(nowcast_elig_counts_final, "aux_geo_label")  
}
```

```{r produce simple output of the aggregates}
my_write.csv <- function(x, suffix) {
  x %>% 
    filter(cps_base_recency == "most_recent") %>% 
    select(-cps_base_recency) %>% 
    write.csv(file = glue("{output_path}Simple elig output by age, period, and outcome -- {suffix}_{my_output_tag}.csv"),
              row.names = FALSE)
}

my_write.csv(nowcast_agg_tract, "by tract")
my_write.csv(nowcast_agg_zip,   "by zcta")
my_write.csv(nowcast_agg_cty,   "by county")
my_write.csv(nowcast_agg_sd,    "by school districts")

if (exists("my_aux_geo")) {
  my_write.csv(nowcast_agg_aux, glue("by {my_aux_geo_desc}"))
}

```

```{r save final aggregates}
to_save <- 
  c("nowcast_agg_tract",
    "nowcast_agg_zip",
    "nowcast_agg_cty",
    "nowcast_agg_sd")
if (exists("my_aux_geo")) {
  to_save <- c(to_save, "nowcast_agg_aux")
}

save(list = to_save,
     file = glue("{output_path}Final ELPEP Estimates in Multiple Geographic Aggregates - {my_output_tag}.Rda"))
```

