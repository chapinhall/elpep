
<!-- This .Rmd file is set up to run either independently by checking for 
the presence of necessary objects in the global environment and running 
related scripts if not, or also as a child to the "main-doc". For that latter
reason, comments and headings that are not relevant to a final report to
pubic audiences are suppressed or moved to code chunks that can optionally be 
`echo`ed as desired. -->

```{r}
# set flags for running this script
print_documentation <- FALSE
```

```{r}
# run scripts for necessary packages and objects as necessary
if (!"chHexs"        %in% objects()) source("settings--main.R", echo = FALSE)
if (!"my_state_abbr" %in% objects()) source("settings--config.R", echo = FALSE)
if (!"bin_age"       %in% objects()) source("method--general-helper-functions.R", echo = FALSE)

Sys.setenv(census_api_key = census_key)
# Check to see that the expected key is output in your R console
Sys.getenv("census_api_key")

options(scipen=999)

```

```{r identify relevant fips codes for population pulls}
my_state_fip <- 
  fips_codes %>% 
  filter(state == my_state_abbr) %>% 
  pull(state_code) %>% 
  unique()

if ("my_county" %in% objects()) {
  my_county_fip <- 
    fips_codes %>% 
    filter(state == my_state_abbr, 
           str_detect(county, my_county)) %>% 
    pull(county_code) %>% 
    unique() 
}

if (exists("my_county_fip")) {
  county_arg <- as.numeric(my_county_fip)
} else {
  county_arg <- NULL
}

```

### Estimating Overall Population Counts for Young Children

This code pulls together data from the [2020 Census redistricting files](https://api.census.gov/data/2020/dec/pl.html) and [2010 SF1 Census files](https://api.census.gov/data/2010/dec/sf1.html) to get population by age group to use in projecting population counts for young children through `r glue('{base_year + 1}')` .

<!-- * For a really helpful video on pulling redistricting data see - https://www.census.gov/library/video/2021/adrm/accessing-2020-census-redistricting-data-through-the-census-data-api-tables-and-group-calls.html -->

2020 Population

* Use 2020 Census DHC to get single-age population data at the tract level

2010 Population

* Use 2010 Census SF1 to get single-age population data at the block group level 
* Use NHGIS 2010-block-groups-to-2020-tract crosswalk to obtain 2010 pop counts for 2020 tracts

```{r pull single-age population counts aged 0, ..., 17 from 2020 DHC}
#Load variables for 2020 DHC
#Also available at https://api.census.gov/data/2020/dec/dhc/variables.html
var_dhc_2020 <- load_variables(2020, dataset = "dhc")

#Filter variables
var_dhc_2020 <- 
  var_dhc_2020 %>% 
  filter(str_detect(name, "P14")) %>% 
  mutate(age = str_extract(label, "\\d+"),
         age = as.numeric(age) - str_detect(label, "Under"),
         sex = case_when(str_detect(label, "Female") ~ "female",
                         str_detect(label, "Male")   ~ "male",
                         TRUE                        ~ "all")) %>% 
  filter(age %in% 0:17,
         !(sex == "all"))

#Block-level pop count by age
pop_block_2020_dhc <-
  get_decennial(
    geography = "block",
    variables = var_dhc_2020$name,
    year = 2020,
    sumfile = "dhc",
    state  = my_state_fip,
    county = county_arg,
    geometry = F) %>% 
  merge(var_dhc_2020 %>% select(-label, -concept),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>% 
  rename(GEOID_BL20 = GEOID)

#Tract-level pop count by age
pop_tract_2020_dhc <-
  get_decennial(
    geography = "tract",
    variables = var_dhc_2020$name,
    year = 2020,
    sumfile = "dhc",
    state  = my_state_fip,
    county = county_arg,
    geometry = F) %>% 
  merge(var_dhc_2020 %>% select(-label, -concept),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>% 
  rename(GEOID_TR20 = GEOID)
  
# Table ID starting with `P`   is available at the as low as block-level
# Table ID starting with `PCT` is available at the as low as tract-level
# P14:   Count by single-year age for the population under 20 years (available at the block/tract level)
# PCT12: Count by single-year age for the total population (available at the tract level); values are equivalent to P14 at the tract level

```

```{r compare block-to-tract aggregated values and tract-level values for 2020 DHC}
pop_block_2020_dhc_to_tract <-
  pop_block_2020_dhc %>%
  mutate(GEOID_TR20 = as.numeric(substr(GEOID_BL20, 1, 11))) %>%
  group_by(GEOID_TR20, age, sex) %>%
  summarise(value = sum(value))

comp <- 
  merge(pop_block_2020_dhc_to_tract,
        pop_tract_2020_dhc,
        by = c("GEOID_TR20", "age", "sex"),
        suffixes = c("_bltotr", "_tract")) %>%
  select(-variable, -NAME)

#check if block_to_tract and tract values are equivalent
comp %>%
  group_by(GEOID_TR20, age, sex) %>%
  summarise(equiv = all(value_bltotr == value_tract)) %>%
  tabyl(equiv)

rm(pop_block_2020_dhc_to_tract, comp)

```

The following codes are generating population counts of certain age groups with 2020 Census PL Redistricting Data and ACS 5-year. This used to be a temporary solution before the 2020 Census DHC was released. As the 2020 Census DHC was released, we compare the population counts from the DHC and the estimates of RD+ACS5.
* 2020 Census PL Redistricting Data: to get tract-level population of kids aged 0-17
* 2018-2022 ACS5: to get age group break-downs by tract
* Combine the above two to get tract-level population of age groups 0-2, 3-4, 5, 6-11, 12-17

```{r pull tract-level 0-17 population data from 2020 PL 94-171 Redistricting Data}
#Load variables for 2020 PL RD
#Also available at https://api.census.gov/data/2020/dec/pl/variables.html
var_rd_2020 <- load_variables(2020, dataset = "pl")

var_rd_2020 <-
  var_rd_2020 %>%
  filter(name %in% c("P1_001N", # Table P1 reflects RACE, and field P1_001N represents Total
                     "P3_001N"  # Table P3 reflects RACE FOR THE POPULATION 18 YEARS AND OVER, and field P3_001N represents Total
                     ))

pop_tract_2020_rd <- 
  get_decennial(
    geography = "tract",
    variables = var_rd_2020$name,
    year = 2020,
    sumfile = "pl",
    state = my_state_fip,
    county = county_arg,
    geometry = FALSE) %>%
  merge(var_rd_2020 %>% select(-label, -concept),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>% 
  rename(GEOID_TR20 = GEOID)

```

```{r rename 2020 field and calculate lt 18 overall population, echo = FALSE}
pop_tract_2020_rd <- 
  pop_tract_2020_rd %>%
  mutate(age = ifelse(str_extract(variable, "^.{2}") == "P1", "Total Population",
               ifelse(str_extract(variable, "^.{2}") == "P3", "18 Plus", NA))) %>%
  select(-variable, -NAME) %>%
  pivot_wider(names_from = age,
              values_from = value) %>% 
  mutate(totallt18_2020 = `Total Population`-`18 Plus`)

# Examine structure
if (FALSE) {
  head(pop_tract_2020_rd)
}

```

```{r compare tract-level data from PL RD and DHC}
#aggregate single-year age tract-level pop counts
pop_tract_2020_dhc_test <-
  pop_tract_2020_dhc %>%
  group_by(GEOID_TR20) %>%
  summarise(totallt18_2020 = sum(value))

comp <- 
  merge(pop_tract_2020_rd, 
        pop_tract_2020_dhc_test, 
        by = "GEOID_TR20",
        suffixes = c("_redis", "_dhc"))

# Examine the differences
summary(comp$totallt18_2020_redis)
summary(comp$totallt18_2020_dhc)

ggplot(comp,
       aes(x = totallt18_2020_redis,
           y = totallt18_2020_dhc)) +
  geom_point(alpha = 0.3) 

# confirmed the 0-17 aggregate of pop counts of DHC is equivalent to pop counts(0-17) of the PL RD
rm(pop_tract_2020_dhc_test, comp)

```

```{r pull ACS 5-year data on age breakdowns}
#Load variables for most recent ACS5
#Also available at https://api.census.gov/data/2022/acs/acs5/variables.html
var_acs5 <- load_variables(acs5_year, dataset = "acs5")

#Filter variables
#Age groups are pulled from ACS 5-year table B09001 Population Under 18 Years by Age
var_acs5 <- 
  var_acs5 %>% 
  filter(str_detect(name, "B09001")) %>% 
  mutate(inhh = str_extract(label, "In households")) %>% 
  filter(!is.na(inhh))

pop_by_age_acs5 <- 
  get_acs(geography = "tract",
          variables = var_acs5$name,
          state = my_state_fip,
          county = county_arg,
          year = acs5_year) %>%
  merge(var_acs5 %>% select(-geography, -inhh),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>% 
  rename(GEOID_TR20 = GEOID)

```

```{r combine acs5 variables into custom age groups}
#Group ages into 0-2, 3-4, 5, 6-11, and 12-17.
pop_by_agegroup_acs5 <- 
  pop_by_age_acs5 %>%
  mutate(variable = recode(variable,
                           "B09001_002" = "total",
                           "B09001_003" = "pop_02",
                           "B09001_004" = "pop_34",
                           "B09001_005" = "pop_5",
                           "B09001_006" = "pop_611",
                           "B09001_007" = "pop_611",
                           "B09001_008" = "pop_1217",
                           "B09001_009" = "pop_1217")) %>%
  group_by(GEOID_TR20, variable) %>%
  summarise(estimate = sum(estimate),
            moe      = moe_sum(moe = moe,
                               estimate = estimate))

# Examine structure
head(pop_by_agegroup_acs5)  

#check
pop_by_agegroup_acs5 %>%
  ungroup() %>% 
  summarise(total  = sum(estimate[variable == "total"]),
            pop_02 = sum(estimate[variable == "pop_02"]),
            pop_34 = sum(estimate[variable == "pop_34"])) %>%
  mutate(percent_0004 = (pop_02 + pop_34)/total*100 %>% round(1))

```

```{r ACS age as percent of total, echo = FALSE, message = FALSE}
#For each age group find their percent of the total

# /!\ Could arguably do this in long form, with a `group_by(GEOID)`, and dispensing
# with the `total` row, replacing it with sum(estimate)
pop_agegroup_pcts_acs5 <-
  pop_by_agegroup_acs5 %>%
  pivot_wider(names_from = variable,
              values_from = c(estimate, moe)) %>%
  mutate(per02_acs   = estimate_pop_02   / estimate_total,
         per34_acs   = estimate_pop_34   / estimate_total,
         per5_acs    = estimate_pop_5    / estimate_total,
         per611_acs  = estimate_pop_611  / estimate_total,
         per1217_acs = estimate_pop_1217 / estimate_total,

         # Reference for arguments -- moe_prop(num, denom, moe_num, moe_denom)         
         per02_moe   = moe_prop(estimate_pop_02,   estimate_total, moe_pop_02,   moe_total),
         per34_moe   = moe_prop(estimate_pop_34,   estimate_total, moe_pop_34,   moe_total),
         per5_moe    = moe_prop(estimate_pop_5,    estimate_total, moe_pop_5,    moe_total),
         per611_moe  = moe_prop(estimate_pop_611,  estimate_total, moe_pop_611,  moe_total),
         per1217_moe = moe_prop(estimate_pop_1217, estimate_total, moe_pop_1217, moe_total),
         
         #Here we are doing a crude cut of the data to get our desired age groups of 6-12 and 13-17
         cut_1217          = estimate_pop_1217 / 6,
         
         # Note for apportioning moe, that the total noise is proportional to 
         # variances, and not moe --
         #   var(a1 + a2 + ... + aN) 
         #     = var(a1) + var(a2) + ... var(aN) 
         #     = N*var(a1) if variances are assumed the same (and correlation = 0)
         # Thus, we need to convert MOE calculations to variances to apportion,
         # and then convert them back
         per1217_se        = per1217_moe / qnorm(0.95), # note: qnorm(0.95) ~== 1.645
         per1217_var       = per1217_se^2,
         cut_1217_var      = per1217_var / 6,
         cut_1217_moe      = sqrt(cut_1217_var) * qnorm(0.95),
         
         estimate_pop_612  = estimate_pop_611  + cut_1217,
         estimate_pop_1317 = estimate_pop_1217 - cut_1217,
         moe_pop_612       = per611_moe        + cut_1217_moe,
         moe_pop_1317      = per1217_moe       - cut_1217_moe,
         
         per612_acs  = estimate_pop_612  / estimate_total,
         per1317_acs = estimate_pop_1317 / estimate_total,
         per612_moe  = moe_prop(estimate_pop_612,  estimate_total, moe_pop_612,  moe_total),
         per1317_moe = moe_prop(estimate_pop_1317, estimate_total, moe_pop_1317, moe_total)) %>%
  select(GEOID_TR20, per02_acs, per34_acs, per5_acs, per612_acs, per1317_acs,
                     per02_moe, per34_moe, per5_moe, per612_moe, per1317_moe)

```

```{r address not-a-number values due to division, echo = FALSE, message = FALSE}
sapply(pop_agegroup_pcts_acs5, function(x) mean(is.nan(x))) %>% sort()
#Get replace a few NaNs with zeros. No kids here (tracts:980000,980100,381700)

pop_agegroup_pcts_acs5 <- replace(pop_agegroup_pcts_acs5, is.na(pop_agegroup_pcts_acs5), 0)

```

```{r add acs to 2020 pop, echo = FALSE, message = FALSE}
#Merge the 2020 population and ACS age group percents
pop_2020_rd_acs5 <-
  merge(x = pop_tract_2020_rd,
        y = pop_agegroup_pcts_acs5,
        by = "GEOID_TR20",
        all.x = TRUE)

# Examine the structure
head(pop_2020_rd_acs5)

```

```{r estimate 2020 age breakdowns, echo = FALSE, message = FALSE}
#Use ACS percents to split the 2020 PL RD less than 18 population into age groups

pop_age_groups_2020_rd_acs5 <-
  pop_2020_rd_acs5 %>%
  mutate(est_2020_02   = round(totallt18_2020*per02_acs,   0),
         est_2020_34   = round(totallt18_2020*per34_acs,   0),
         est_2020_5    = round(totallt18_2020*per5_acs,    0),
         est_2020_612  = round(totallt18_2020*per612_acs,  0),
         est_2020_1317 = round(totallt18_2020*per1317_acs, 0),
         
         # Note: reference for arguments is `moe_product(est1, est2, moe1, moe2)`
         # This implicitly assumes that 
         moe_2020_02   = moe_product(totallt18_2020, per02_acs,   0, per02_moe),
         moe_2020_34   = moe_product(totallt18_2020, per34_acs,   0, per34_moe),
         moe_2020_5    = moe_product(totallt18_2020, per5_acs,    0, per5_moe),
         moe_2020_612  = moe_product(totallt18_2020, per612_acs,  0, per612_moe),
         moe_2020_1317 = moe_product(totallt18_2020, per1317_acs, 0, per1317_moe)
         ) %>%
  select(GEOID_TR20,
         est_2020_02, est_2020_34, est_2020_5, est_2020_612, est_2020_1317,
         moe_2020_02, moe_2020_34, moe_2020_5, moe_2020_612, moe_2020_1317) %>%
  pivot_longer(cols = -GEOID_TR20,
               names_to  = "variable",
               values_to = "value") %>%
  separate(variable, 
           into = c("variable", "year", "agegroup")) %>%
  pivot_wider(names_from  =  c("variable","year"),
              values_from = "value",
              names_sep   =  "_") %>%
  mutate(
    agegroup_code = recode(agegroup,
                           "02"   = 1,
                           "34"   = 2 ,
                           "5"    = 3,
                           "612"  = 4,
                           "1317" = 5))

```

```{r compare pop est by age groups from ACS5+RD vs. DHC, echo = FALSE, message = FALSE}
pop_age_groups_2020_dhc <-
  pop_tract_2020_dhc %>% 
  select(-variable, NAME) %>%
  mutate(agegroup = 
           case_when(between(age,  0,  2) ~ "02",
                     between(age,  3,  4) ~ "34",
                     age == 5             ~ "5",
                     between(age,  6, 12) ~ "612",
                     between(age, 13, 17) ~ "1317")) %>% 
  group_by(GEOID_TR20, agegroup) %>%
  summarise(value = sum(value))
  
comp_dhc_redis_acs5 <- 
  merge(pop_age_groups_2020_dhc,
        pop_age_groups_2020_rd_acs5 %>% rename(value = est_2020),
        by = c("GEOID_TR20", "agegroup"),
        suffixes = c("_dhc", "_redis_acs5"))

ggplot(comp_dhc_redis_acs5,
       aes(x = value_redis_acs5,
           y = value_dhc)) +
  geom_abline() + 
  geom_point(alpha = 0.3) +
  geom_smooth()

rm(comp_dhc_redis_acs5)
rm(var_rd_2020, pop_tract_2020_rd, var_acs5, pop_by_age_acs5, pop_by_agegroup_acs5, pop_agegroup_pcts_acs5, pop_2020_rd_acs5)

```

## Census Population Data from 2010 Summary File 1

```{r pull single-age population counts aged 0, ..., 17 from 2010 SF1}
#Load variables for 2020 DHC
var_sf1_2010 <- load_variables(2010, dataset = "sf1")

#Filter variables
var_sf1_2010 <- 
  var_sf1_2010 %>% 
  filter(str_detect(name, "P014")) %>% #name, ("PCT012|P012|P014")
  mutate(age = str_extract(label, "\\d+"),
         age = as.numeric(age) - str_detect(label, "Under"),
         age = ifelse(is.na(age), "all", age),
         sex = case_when(str_detect(label, "Female") ~ "female",
                         str_detect(label, "Male")   ~ "male",
                         TRUE                        ~ "all")) %>% 
  filter(age %in% 0:17,
         !(sex == "all"))

#Block-level pop count by age
pop_block_2010_sf1 <-
  get_decennial(
    geography = "block",
    variables = var_sf1_2010$name,
    year = 2010,
    sumfile = "sf1",
    state  = my_state_fip,
    county = county_arg,
    geometry = F) %>% 
  merge(var_sf1_2010 %>% select(-label, -concept),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>%
  rename(GEOID_BL10 = GEOID) %>% 
  mutate(GEOID_TR10 = str_sub(GEOID_BL10, 1, 11)) # get tract-level GEOID

#Block-group-level pop count by age
pop_bg_2010_sf1 <-
  get_decennial(
    geography = "block group",
    variables = var_sf1_2010$name,
    year = 2010,
    sumfile = "sf1",
    state  = my_state_fip,
    county = county_arg,
    geometry = F) %>% 
  merge(var_sf1_2010 %>% select(-label, -concept),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>% 
  rename(GEOID_BG10 = GEOID) %>%
  mutate(GEOID_TR10 = str_sub(GEOID_BG10, 1, 11)) # get tract-level GEOID

#Tract-level pop count by age
pop_tract_2010_sf1 <-
  get_decennial(
    geography = "tract",
    variables = var_sf1_2010$name,
    year = 2010,
    sumfile = "sf1",
    state  = my_state_fip,
    county = county_arg,
    geometry = F) %>% 
  merge(var_sf1_2010 %>% select(-label, -concept),
        by.x = "variable",
        by.y = "name",
        all = TRUE) %>%
  rename(GEOID_TR10 = GEOID)

```

```{r compare block-to-tract aggregated values and tract-level values for 2010 SF1}
pop_block_2010_sf1_to_tract <-
  pop_block_2010_sf1 %>%
  mutate(GEOID_TR10 = as.numeric(substr(GEOID_BL10, 1, 11))) %>%
  group_by(GEOID_TR10, age, sex) %>%
  summarise(value = sum(value))

comp <- 
  merge(pop_block_2010_sf1_to_tract,
        pop_tract_2010_sf1,
        by = c("GEOID_TR10", "age", "sex"),
        suffixes = c("_bltotr", "_tract")) %>%
  select(-variable, -NAME)

#check if block_to_tract and tract values are equivalent
comp %>%
  group_by(GEOID_TR10, age, sex) %>%
  summarise(equiv = all(value_bltotr == value_tract)) %>%
  tabyl(equiv)

rm(pop_block_2010_sf1_to_tract, comp)

```

```{r develop 2010 block group to 2020 tract crosswalk, echo = FALSE, message = FALSE}
# See https://www.nhgis.org/geographic-crosswalks#from-block-groups
# Download crosswalks from 2010 block groups to 2020 census tracts
# url: https://data2.nhgis.org/crosswalks/nhgis_bg2010_tr2020.zip 
# It's necessary to sign in to download

xwk_bg2010_tr2020 <-
  read_nhgis(glue("{input_path}nhgis_bg2010_tr2020.zip")) %>% 
  #wt_pop: Expected proportion of source zone's `population` located in target zone
  select(GEOID_BG10 = bg2010ge, 
         GEOID_TR20 = tr2020ge, 
         wt_pop) %>%
  mutate(statefip = as.character(substr(GEOID_TR20, 1, 2))) %>%
  filter(statefip == {my_state_fip})

```

```{r implement use of crosswalk, echo = FALSE, message = FALSE}
#Merge crosswalk and 2010 block group data to get 2010 pop counts for 2020 tracts
pop_bg_2010_tr2020 <-
  merge(pop_bg_2010_sf1,
        xwk_bg2010_tr2020,
        by = "GEOID_BG10",
        all.x = T) %>% 
  select(-variable, -statefip) %>% 
  rename(pop_bg2010 = value,
         NAME_BG10  = NAME) %>%
  #Multiply 2010 pop counts for 2010 block group (pop_bg2010) by interpolation weights (wt_pop)
  mutate(pop_tr2020 = pop_bg2010*wt_pop,
         GEOID_TR10 = str_sub(GEOID_BG10, 1, 11)) %>%
  select(GEOID_BG10, GEOID_TR10, GEOID_TR20, sex, age, pop_bg2010, wt_pop, pop_tr2020, NAME_BG10)

head(pop_bg_2010_tr2020)

pop_bg_2010_agegroup <- 
  pop_bg_2010_sf1 %>% 
  group_by(GEOID_BG10, age) %>%
  summarise(value = sum(value)) %>% 
  ungroup() %>% 
  mutate(big_agegroup = 
           case_when(age %in% 0:2   ~ "pop_0004",
                     age %in% 5:9   ~ "pop_0509",
                     age %in% 10:14 ~ "pop_1014",
                     age %in% 15:17 ~ "pop_1517",
                     TRUE           ~ NA)) %>%
  group_by(GEOID_BG10, big_agegroup) %>%
  summarise(bigpop_bg2010 = sum(value))

pop_bg_2010_tr2020_agegroup <-
  merge(pop_bg_2010_agegroup,
        xwk_bg2010_tr2020,
        by = "GEOID_BG10",
        all.x = T) %>% 
  mutate(bigpop_tr2020 = bigpop_bg2010*wt_pop)

pop_bg_2010_tr2020_agegroup <- 
  pop_bg_2010_sf1 %>% 
  group_by(GEOID_BG10, age) %>%
  summarise(value = sum(value)) %>% 
  ungroup() %>% 
  mutate(agegroup = 
           case_when(age %in% 0:2   ~ "02",
                     age %in% 3:4   ~ "34",
                     age == 5       ~ "5",
                     age %in% 6:12  ~ "612",
                     age %in% 13:17 ~ "1317",
                     TRUE           ~ NA)) %>%
  group_by(GEOID_BG10, agegroup) %>%
  summarise(grvalue = sum(value)) %>%
  merge(xwk_bg2010_tr2020,
        by = "GEOID_BG10",
        all.x = T) %>%
  select(-statefip) %>%
  mutate(est = (grvalue*wt_pop) %>% round(0)) %>%
  group_by(GEOID_TR20, agegroup) %>%
  summarise(est_2010 = sum(est))

pop_bg_2010_tr2020_agegroup_test2 <- 
  pop_bg_2010_sf1 %>% 
  group_by(GEOID_BG10, age) %>%
  summarise(value = sum(value)) %>%
  merge(xwk_bg2010_tr2020,
        by = "GEOID_BG10",
        all.x = T) %>%
  mutate(pop_tr2020 = (value*wt_pop) %>% round(0)) %>%
  ungroup() %>% 
  mutate(agegroup = 
           case_when(age %in% 0:2   ~ "02",
                     age %in% 3:4   ~ "34",
                     age == 5       ~ "5",
                     age %in% 6:12  ~ "612",
                     age %in% 13:17 ~ "1317",
                     TRUE           ~ NA)) %>%
  group_by(GEOID_TR20, agegroup) %>%
  summarise(est_2010 = sum(pop_tr2020))

```

```{r develop 2010 block to 2020 block crosswalk, echo = FALSE, message = FALSE}
# See https://www.nhgis.org/geographic-crosswalks#from-block-groups
# Download crosswalks from 2010 block groups to 2020 census tracts (GEOID identifiers)
# url: https://data2.nhgis.org/crosswalks/nhgis_blk2010_blk2020_ge.zip
# It's necessary to sign in to download
xwk_bl2010_bl2020 <-
  read_nhgis(glue("{input_path}nhgis_blk2010_blk2020_ge.zip")) %>% 
  select(GEOID_BL10 = GEOID10,
         GEOID_BL20 = GEOID20,
         WEIGHT) %>%
  mutate(statefip = as.character(substr(GEOID_BL20, 1, 2))) %>%
  filter(statefip == {my_state_fip})

```

```{r census tract10 to tract20 crosswalk}
# See this link, and search for "Census Tract Relationship Files":
#   https://www.census.gov/geographies/reference-files/time-series/geo/relationship-files.html
# Documentation is here:
#   https://www2.census.gov/geo/pdfs/maps-data/data/rel2020/tract/explanation_tab20_tract20_tract10.pdf
rel_tr2020_tr2010 <- 
  fread("https://www2.census.gov/geo/docs/maps-data/data/rel2020/tract/tab20_tract20_tract10_natl.txt") %>% 
  mutate(GEOID_TR20 = str_pad(GEOID_TRACT_20, width = 11, side = "left", pad = "0"),
         GEOID_TR10 = str_pad(GEOID_TRACT_10, width = 11, side = "left", pad = "0"),
         statefip   = substr(GEOID_TR20, 1, 2)) %>%
  filter(statefip == {my_state_fip}) %>% 
  select(GEOID_TR20, GEOID_TR10, AREALAND_TRACT_20, AREALAND_TRACT_10) %>% 
  mutate(GEOID_TR20        = as.character(GEOID_TR20),
         GEOID_TR10        = as.character(GEOID_TR10),
         AREALAND_TRACT_20 = as.numeric(AREALAND_TRACT_20),
         AREALAND_TRACT_10 = as.numeric(AREALAND_TRACT_10)) %>% 
  group_by(GEOID_TR20) %>% 
  mutate(pct_10_in_20 = AREALAND_TRACT_10 / sum(AREALAND_TRACT_10)) %>% 
  #ungroup() %>% 
  group_by(GEOID_TR10) %>% 
  mutate(pct_20_in_10 = AREALAND_TRACT_20 / sum(AREALAND_TRACT_20))

# Inspect calculations
if (FALSE) {
  rel_tr2020_tr2010 %>% filter(GEOID_TR20 == "17001000100")
  rel_tr2020_tr2010 %>% filter(GEOID_TR10 == "17001010400")
}
if (FALSE) {
  rel_tr2020_tr2010 %>% filter(GEOID_TR20 == "23001010100")
  rel_tr2020_tr2010 %>% filter(GEOID_TR10 == "23001010400")
}

#Inspect distinct number of each GEOID_TRACT
if (FALSE) {
  rel_tr2020_tr2010$GEOID_TR20 %>% unique() %>% length() #3,265 for IL, #407 for MA
  rel_tr2020_tr2010$GEOID_TR10 %>% unique() %>% length() #3,124 for IL, #358 for MA
}

#Inspect NAs
if (FALSE) {
  rel_tr2020_tr2010 %>% filter(is.na(pct_10_in_20)|is.na(pct_20_in_10))
  rel_tr2020_tr2010 %>% filter(AREALAND_TRACT_10 == 0 | AREALAND_TRACT_20 == 0)
  rel_tr2020_tr2010 %>% filter(str_detect(GEOID_TR10, "990000$|990100$") | str_detect(GEOID_TR10, "990000$|990100$"))
}

```

```{r recode remaining zeros in the 2010 final, echo = FALSE, message = FALSE}
sapply(pop_bg_2010_tr2020_agegroup, function(x) mean(is.na(x)) %>% sort())
pop_bg_2010_tr2020_agegroup <- replace(pop_bg_2010_tr2020_agegroup, is.na(pop_bg_2010_tr2020_agegroup), 0)
sapply(pop_bg_2010_tr2020_agegroup, function(x) mean(is.na(x)) %>% sort())

```

### Combine 2010 and 2020 at tract level to prep for interpolation of years between Census

```{r merge tract, echo=FALSE}
pop_2010_2020_tract <-
  merge(pop_age_groups_2020_dhc %>% rename(est_2020 = value),
        pop_bg_2010_tr2020_agegroup,
        by = c("GEOID_TR20",   "agegroup"),
        #by.y = c("GEOID_TR20", "agegroup"),
        all.x = TRUE) %>%
  pivot_longer(cols = c("est_2010", "est_2020"),
               names_to = 'variable',
               values_to = 'pop_est') %>%
  separate(variable, 
           into = c("pop","year")) %>%
  select(-pop)

#replace zeros with 1
pop_2010_2020_tract$pop_est <-
  replace(pop_2010_2020_tract$pop_est, 
          pop_2010_2020_tract$pop_est < 1,
          1) 

```


### Interpolate estimates for intercensal years

Borrow from Nick's 2019 code here. Note that we do a linear interpolation between 2010 and 2020 estimates. 
Although this is a very simplistic scheme, we noted in previous work that estimates for
the total population aged 14 and below follows a nearly linear pattern. 


```{r generate data frame for interpolate}
# Take all unique tract/age-group combinations from the 2010/2020 data,
# create a frame with all years from 2010 to 2020, and merge in endpoint data.

allyears <-
  pop_2010_2020_tract %>%
  select(-pop_est,-year) %>%
  distinct(GEOID_TR20, agegroup) %>%
  group_by(GEOID_TR20, agegroup) %>% 
  mutate(year = list(2010:2020)) %>% 
  unnest(cols = year)

interp_frame <-
  merge(allyears,
        pop_2010_2020_tract,
        by = c("GEOID_TR20", "agegroup", "year"),
        all.x = T)

```


```{r Check for tracts with no data for interpolatee}
insufficient_interp_tracts <-
  interp_frame %>% 
  mutate(n = sum(!is.na(pop_est)))

mean(insufficient_interp_tracts$n < 2)

unique(insufficient_interp_tracts %>% filter(n < 2) %>% pull(GEOID_TR20))

insufficient_interp_tracts <-
  insufficient_interp_tracts %>% 
  filter(n < 2)

### Interpolate ----------------------------------------------------------------
# na.interp is from forecast package
ests_interp <-
  interp_frame %>% 
  group_by(GEOID_TR20, agegroup) %>% 
  mutate(pop_interp = na.interp(pop_est))

# Examine structure
head(ests_interp, 12)

```

### Use the forecast package to get 2021 estimates 

```{r get next year estimate}
#Make a tibble
ests_interp <- ests_interp %>%
  #mutate(Year = year(year)) %>%
  as_tsibble(key = c(GEOID_TR20, agegroup),
             index = year)


#forecasts for 2021 generated from Holt's method.
system.time({fit <- 
  ests_interp %>%
  model(
    AAN = ETS(pop_interp ~ error("A") + trend("A") + season("N")) 
  )
})

# Damped Holt's method
# model(
#     AAN = ETS(pop_interp ~ error("A") + trend("Ad", phi = 0.9) + season("N")) 
#   )

fc <- fit %>% forecast(h = max(1, base_year + 1 - 2020))

#We end up with some negative values here - 190 observations (<5%)
#These are tracts with no kids in that age group in ACS - I think this is okay - we'll round up to 0

est_forecast <-
  as.data.frame(fc) %>%
  mutate(pop_interp = ifelse(.mean < 0, 0, floor(.mean))) %>%
  select(GEOID_TR20, agegroup, year, pop_interp)

```

### Reshape the estimates and export

```{r reshape and export to H drive}
#Round interpolated estimates
ests20102020 <-
  as.data.frame(ests_interp) %>%
  mutate(pop_interp = round(pop_interp, 0)) %>% 
  select(GEOID_TR20, agegroup, year, pop_interp)

ests_with_forecast <- 
  rbind(ests20102020, est_forecast)

```

```{r examine forecast estimates}
ests_with_forecast %>% 
  ggplot(aes(x = year,
             y = pop_interp)) +
  geom_point(alpha = 0.3) +
  geom_smooth() + 
  geom_vline(xintercept = 2020.5,
             color = "red") +
  scale_x_continuous(breaks = 2010:(base_year+1),
                     labels = 2010:(base_year+1)) +
  facet_wrap(~ agegroup) +
  theme_minimal()

```

```{r examine time path of pct 0-2 out of under 6}
pcts_under6 <-
  ests_with_forecast %>% 
  filter(agegroup %in% c("02", "34", "5")) %>% 
  group_by(GEOID_TR20, year) %>% 
  mutate(pct = pop_interp / sum(pop_interp))

pcts_under6 %>%
  filter(agegroup == "02") %>%
  ggplot(aes(x = year,
             y = pct,
             group = GEOID_TR20)) +
  geom_line(alpha = 0.1) +
  theme_minimal()

```

```{r examine breakdown of ages based on size of the under 6 population}
pcts_under6 %>%
  filter(agegroup == "02",
         year == {base_year}) %>% 
  ggplot(aes(x = pop_interp,
             y = pct)) +
  geom_point(alpha = 0.2) +
  geom_smooth() +
  theme_minimal()

pcts_under6 %>%
  filter(agegroup == "02",
         year == {base_year+1}) %>% 
  ggplot(aes(x = pop_interp,
             y = pct)) +
  geom_point(alpha = 0.2) +
  geom_smooth() +
  theme_minimal()

```

```{r convert the current population tracts from 2020 to 2010 to conform with SAE methods}
#/!\hk: is this necessary? ACS1 no longer uses 2010 geography
if (FALSE) {
  ests_tracts <- unique(ests_with_forecast$GEOID_TR20)
  mean(ests_tracts %in% rel_tr2020_tr2010$GEOID_TR20)
  mean(ests_tracts %in% rel_tr2020_tr2010$GEOID_TR10)
  
  ests_with_forecast_xwalk <- 
    ests_with_forecast %>% 
    merge(rel_tr2020_tr2010,
          by.x = "GEOID_TR20",
          by.y = "GEOID_TR20",
          all.x = TRUE) %>%
    mutate(pop_interp_part = pop_interp*pct_20_in_10) %>% 
    group_by(GEOID_TR10, agegroup, year) %>% 
    summarize(pop_interp = sum(pop_interp_part))
  
  mean(unique(ests_with_forecast_xwalk$GEOID_TR10) %in% rel_tr2020_tr2010$GEOID_TR10)
}

```

```{r reshape and save}
if (FALSE) {
  ests_with_forecast_wide <-
    ests_with_forecast_xwalk %>% 
    pivot_wider(id_cols = c(GEOID_TR10, agegroup), 
                names_from = year,
                names_prefix = "est",
                values_from = pop_interp)
  
  write.csv(ests_with_forecast_wide,
            glue("{output_path}est_age0017_2010_{base_year + 1}_{my_output_tag}.csv"), 
            row.names = FALSE)
}

```

```{r reshape and save with GEOID_tr20}
ests_with_forecast_wide <-
  ests_with_forecast %>% 
  pivot_wider(id_cols = c(GEOID_TR20, agegroup), 
              names_from = year,
              names_prefix = "est",
              values_from = pop_interp)

write.csv(ests_with_forecast_wide,
           glue("{output_path}est_age0017_2010_{base_year + 1}_{my_output_tag}.csv"), 
           row.names = FALSE)

```

```{r source population data}
# /!\ When further developed, it would be valuable to address standard errors
# of population counts based on sampling and statistical forecasting. The
# 02b script currently assumes that standard errors are 0 (i.e. that these 
# estimates are perfectly precise).
pop_by_age <- 
  ests_with_forecast_wide %>% 
  mutate(GEOID_TR20 = as.character(GEOID_TR20),
         age        = case_when(agegroup == "2"    ~ "age_0to2_count",          
                                agegroup == "34"   ~ "age_3to4_count",
                                agegroup == "5"    ~ "age_5_count",
                                agegroup == "612"  ~ "age_6to12_count",
                                agegroup == "1317" ~ "age_13to17_count")) %>% 
  pivot_longer(cols = starts_with("est")) %>% 
  group_by(GEOID_TR20, name, age) %>% 
  summarize(value = sum(value)) %>% 
  pivot_wider(names_from  = "age",
              values_from = "value") %>% 
  mutate(age_0to5_count = age_0to2_count + age_3to4_count + age_5_count,
         age_4_count    = round(age_3to4_count/2, 0),
         age_3to5_count = age_3to4_count + age_5_count,
         year = str_extract(name, "\\d+") %>% as.numeric()) %>% 
  ungroup() %>% 
  select(-name)

```

```{r compare these population estimates to those in ACS5}
load(glue("{output_path}acs5_data_{my_output_tag}.Rda"))

comp_pop <- 
  pop_by_age %>% 
  filter(year == {acs5_year-2}) %>% # midpoint of the ACS5 data that currently have been pulled
  merge(acs5tract %>% select(GEOID, age_0to5_count, age_6to12_count),
        by.x = "GEOID_TR20",
        by.y = "GEOID",
        #all = TRUE,
        suffixes = c(".pop", ".acs5"))

ggplot(comp_pop,
       aes(x = age_0to5_count.pop,
           y = age_0to5_count.acs5)) +
  geom_point(alpha = 0.3) + 
  geom_45(color = "blue") +
  geom_smooth(color = "red") +
  theme_minimal()

ggplot(comp_pop,
       aes(x = age_6to12_count.pop,
           y = age_6to12_count.acs5)) +
  geom_point(alpha = 0.3) + 
  geom_45(color = "blue") +
  geom_smooth(color = "red") +
  theme_minimal()

```

```{r save}
save(pop_by_age,
     file = glue("{output_path}pop_data_{my_output_tag}.Rda"))
```

```{r reapportion population estimates to 2010 census geographies and save data}
if (base_year <= 2021) {
  rel_10_20 <- 
    fread("https://www2.census.gov/geo/docs/maps-data/data/rel2020/tract/tab20_tract20_tract10_natl.txt", sep = "|") %>% 
    mutate(GEOID_TR10        = str_pad(GEOID_TRACT_10, width = 11, side = "left", pad = "0"),
           GEOID_TR20        = str_pad(GEOID_TRACT_20, width = 11, side = "left", pad = "0"),
           statefip          = substr(GEOID_TR20, 1, 2),
           AREALAND_PART     = as.numeric(AREALAND_PART),
           AREALAND_TRACT_20 = as.numeric(AREALAND_TRACT_20)
            # Note -- the `as.numeric()` functions are necessary to convert values
            # from integer64 values, which can cause errors in calculation
           ) %>% 
    filter(statefip == {my_state_fip}) %>% 
    mutate(part_of_20 = AREALAND_PART / AREALAND_TRACT_20)

  ests_with_forecast_long <- 
    ests_with_forecast_wide %>%
    pivot_longer(cols = starts_with("est")) %>% 
    mutate(year = str_extract(name, "\\d+") %>% as.numeric(),
           age = case_when(agegroup == "02"   ~ "age_0to2_count",
                           agegroup == "34"   ~ "age_3to5_count",
                           agegroup == "5"    ~ "age_3to5_count",
                           agegroup == "612"  ~ "age_6to12_count",
                           agegroup == "1317" ~ "age_13to17_count")) %>% 
    group_by(age, GEOID_TR20, year) %>%
    summarise(value = sum(value))
  
  pop_by_age <- 
    ests_with_forecast_long %>% 
    merge(rel_10_20 %>% select(GEOID_TR20, GEOID_TR10, part_of_20),
          by = "GEOID_TR20",
          all.x = TRUE) %>% 
    mutate(value = value * part_of_20) %>% 
    group_by(GEOID_TR10, age, year) %>% 
    summarize(value = sum(value))

  save(pop_by_age,
       file = glue("{output_path}pop_data_{my_output_tag}.Rda"))
}

```
